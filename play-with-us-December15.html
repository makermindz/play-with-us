<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated STEAM Simulation Hub</title>
    <!-- Load Tailwind CSS for utility classes and the Inter font -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'green-primary': '#27ae60', /* Darker Green */
                        'green-secondary': '#2ecc71', /* Brighter Green */
                        'green-light': '#f4fff4',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        /* Base Styles and Layout Resets */
        body {
            background-color: #ffffff; /* Light background for the whole page */
            font-family: 'Inter', sans-serif;
        }

        /* Generic container for all game sections */
        .game-card {
            margin-top: 2.5rem;
            padding: 1.5rem;
            border-radius: 1rem;
            background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* Two-column layout responsiveness */
        .game-grid {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        @media (min-width: 768px) {
            .game-grid {
                flex-direction: row;
            }
        }
        
        /* Consistent Canvas/Sim/Graph Area Styles */
        .sim-area {
            width: 100%;
            height: 300px; /* Reduced height to fit more games */
            background-color: #e9f5e9; 
            border: 2px solid #2ecc71;
            border-radius: 0.5rem;
            margin-top: 1rem;
            position: relative;
        }
        
        /* Button and Input Styling */
        input[type="number"], input[type="text"], select {
            -moz-appearance: textfield; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            border-radius: 0.375rem;
            padding: 0.5rem;
            border: 1px solid #ccc;
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .btn-action {
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: bold;
        }
        .btn-action:hover {
            opacity: 0.9;
        }
        .btn-action:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        .info-panel {
            min-height: 280px; /* Ensure info panel is tall enough */
        }

        /* Style for the superscript brand name in titles */
        h2 sup {
            font-size: 0.45em; /* Makes the text much smaller */
            color: #6b7280;   /* A pleasant, readable grey */
            font-weight: 500; /* Lighter than the extrabold title */
            margin-left: 6px; /* Adds a bit of space from the title */
        }

    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-6xl w-full mx-auto">
        <h1 class="text-4xl font-extrabold text-gray-800 border-b-4 border-green-secondary pb-4 mb-8 text-center">
            STEAM Simulation Hub
        </h1>

        <!-- ========================================================================================= -->
        <!-- GAME 1: LINEAR REGRESSION FITTER (Math/Data Science) -->
        <!-- ========================================================================================= -->
        <div id="game-regression" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Linear Regression Fitter<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Statistical Modeling</h3>
                    <p class="text-gray-700 mb-4">Linear Regression is a statistical method used to model the relationship between a scalar response and explanatory variables. It assumes a linear relationship, represented by the equation:</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        y = m * x + b
                    </div>
                    <p class="text-gray-700 mb-4">The goal is to find the slope (m) and y-intercept (b) that minimizes the Sum of Squared Errors between the data points and the line. You must adjust m and b to manually find the best fit line for the data points.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner mb-4">
                        <div>
                            <label for="slope" class="text-sm font-semibold text-gray-700">Slope (m):</label>
                            <input type="number" id="slope" step="0.1" value="0.5" class="w-20 p-2 border border-gray-300 rounded-md text-center">
                        </div>
                        <div>
                            <label for="intercept" class="text-sm font-semibold text-gray-700">Intercept (b):</label>
                            <input type="number" id="intercept" step="0.1" value="1.0" class="w-20 p-2 border border-gray-300 rounded-md text-center">
                        </div>
                        <button onclick="updateRegressionPlot()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Fit Line
                        </button>
                    </div>
                    <canvas id="regressionCanvas" class="sim-area"></canvas>
                    <div id="regressionMessage" class="text-center mt-4 p-2 bg-yellow-100 text-gray-800 font-semibold rounded-lg">
                        Adjust m and b to minimize the distance to the points.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 2: QUADRATIC FUNCTION EXPLORER (Math) - NEW REPLACEMENT -->
        <!-- ========================================================================================= -->
        <div id="game-quadratic" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Quadratic Function Explorer<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Parabola Analysis</h3>
                    <p class="text-gray-700 mb-4">A quadratic function produces a U-shaped curve called a parabola. The standard form of the equation is:</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        y = ax<sup>2</sup> + bx + c
                    </div>
                    <p class="text-gray-700 mb-4">The coefficient a controls the direction and width. b and c shift the parabola's position. The vertex (minimum or maximum point) is located at x = -b / (2a).</p>
                    <p class="text-gray-700">Use the sliders to see how each coefficient impacts the graph's shape and position.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-8">a:</label>
                            <input type="range" id="qa" min="-2" max="2" step="0.1" value="1" class="flex-grow" oninput="drawQuadratic()">
                            <span id="qa-val" class="font-bold text-green-primary w-10 text-center">1.0</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-8">b:</label>
                            <input type="range" id="qb" min="-5" max="5" step="0.1" value="0" class="flex-grow" oninput="drawQuadratic()">
                            <span id="qb-val" class="font-bold text-green-primary w-10 text-center">0.0</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-8">c:</label>
                            <input type="range" id="qc" min="-5" max="5" step="0.1" value="0" class="flex-grow" oninput="drawQuadratic()">
                            <span id="qc-val" class="font-bold text-green-primary w-10 text-center">0.0</span>
                        </div>
                    </div>
                    <canvas id="quadraticCanvas" class="sim-area"></canvas>
                    <div id="quadraticMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Vertex: (0.00, 0.00). Roots: 0.00, 0.00.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 3: HEAT TRANSFER SIMULATOR (Science/Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-heat" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Heat Transfer Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Thermal Dynamics</h3>
                    <p class="text-gray-700 mb-4">Heat transfer occurs via three main mechanisms: Conduction (transfer through contact), Convection (transfer through fluid motion), and Radiation (transfer via electromagnetic waves).</p>
                    <p class="text-gray-700 mb-4">This simulation models conduction between two objects. The rate of heat flow is proportional to the Temperature Difference and the Thermal Conductivity of the material.</p>
                    <p class="text-gray-700">Watch how quickly the cold block (Blue) reaches thermal equilibrium with the hot block (Red) based on the material's conductivity.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="conductivity" class="text-sm font-semibold text-gray-700">Material:</label>
                        <select id="conductivity" class="p-2 border border-gray-300 rounded-md" onchange="resetHeatSim()">
                            <option value="0.01">Wood (Low)</option>
                            <option value="0.5">Steel (Medium)</option>
                            <option value="1.5">Copper (High)</option>
                        </select>
                        <button onclick="startHeatSim()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Start/Reset Sim
                        </button>
                    </div>
                    <canvas id="heatCanvas" class="sim-area"></canvas>
                    <div id="heatMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Block 1 Temp: 80°C | Block 2 Temp: 20°C
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 4: DNA COMPLEMENT GENERATOR (Science/Biology) -->
        <!-- ========================================================================================= -->
        <div id="game-dna" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                DNA Complement Generator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Molecular Biology</h3>
                    <p class="text-gray-700 mb-4">DNA consists of two strands linked by base pairs. The four nitrogenous bases are Adenine (A), Thymine (T), Guanine (G), and Cytosine (C). Base pairing is always specific:</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        A pairs with T | G pairs with C
                    </div>
                    <p class="text-gray-700">The goal is to determine the complementary strand for a given DNA sequence. This process is essential for DNA replication and transcription.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="dna-input" class="text-sm font-semibold text-gray-700">Original Strand (A, T, G, C):</label>
                        <input type="text" id="dna-input" value="ATGCGTAG" class="p-2 border border-gray-300 rounded-md text-center uppercase" placeholder="Enter DNA Sequence">
                        <button onclick="generateComplement()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Generate Complement
                        </button>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Complementary Strand:</p>
                        <p id="dna-output" class="text-xl font-mono text-red-600 break-all">TACGCATC</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 5: ARRAY SORTING CHALLENGE (CS/Tech) -->
        <!-- ========================================================================================= -->
        <div id="game-sort" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Array Sorting Challenge<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Algorithm Efficiency</h3>
                    <p class="text-gray-700 mb-4">Sorting algorithms are fundamental to computer science. They arrange elements of a list in a specified order. Common methods include Bubble Sort, Merge Sort, and Quick Sort.</p>
                    <p class="text-gray-700 mb-4">This challenge visualizes an array of numbers. Your task is to apply an algorithm (Bubble Sort is used here) to arrange the numbers from smallest to largest.</p>
                    <p class="text-gray-700">Use the buttons to step through the sorting process and observe how values are swapped until the array is completely sorted.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <button onclick="resetArray()" class="btn-action px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                            Reset Array
                        </button>
                        <button onclick="sortStep()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Next Step
                        </button>
                    </div>
                    <canvas id="sortCanvas" class="sim-area"></canvas>
                    <div id="sortMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Initial Array. Press Next Step to begin Bubble Sort.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 6: CENTER OF GRAVITY FINDER (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-cog" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Center of Gravity Finder<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Equilibrium and Stability</h3>
                    <p class="text-gray-700 mb-4">The Center of Gravity (CoG) is the imaginary point where the total weight of an object is considered to be concentrated. An object is stable only if its CoG is above its base of support.</p>
                    <p class="text-gray-700 mb-4">In a rigid body, the CoG is the weighted average of the positions of all the mass elements.</p>
                    <p class="text-gray-700">Click anywhere in the area to add a mass block (Black Dot). The simulation will instantly calculate and display the system's overall Center of Gravity (Red Cross).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <canvas id="cogCanvas" class="sim-area cursor-pointer" onclick="addMass(event)"></canvas>
                    <div class="controls flex gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mt-4">
                        <button onclick="resetCogSim()" class="btn-action px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                            Clear Masses
                        </button>
                    </div>
                    <div id="cogMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        CoG: (X: 0, Y: 0). Click to add mass.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 7: COLOR THEORY MIXER (Art/Science) -->
        <!-- ========================================================================================= -->
        <div id="game-color" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Color Theory Mixer (RGB)<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Additive Light Theory</h3>
                    <p class="text-gray-700 mb-4">The RGB (Red, Green, Blue) model is an additive color system used in digital displays. Additive means that light is mixed: starting with black, adding R, G, and B light creates brighter colors.</p>
                    <p class="text-gray-700 mb-4">The intensity of each color channel is measured from 0 (off) to 255 (full intensity). Equal amounts of all three at 255 produce white.</p>
                    <p class="text-gray-700">Adjust the three sliders to see the resulting color mixture. Learn how different levels of light create complex shades.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-8 text-red-600">R:</label>
                            <input type="range" id="colorR" min="0" max="255" value="128" class="flex-grow" oninput="updateColorMixer()">
                            <span id="colorR-val" class="font-bold text-gray-800 w-10 text-center">128</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-8 text-green-500">G:</label>
                            <input type="range" id="colorG" min="0" max="255" value="128" class="flex-grow" oninput="updateColorMixer()">
                            <span id="colorG-val" class="font-bold text-gray-800 w-10 text-center">128</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-8 text-blue-600">B:</label>
                            <input type="range" id="colorB" min="0" max="255" value="128" class="flex-grow" oninput="updateColorMixer()">
                            <span id="colorB-val" class="font-bold text-gray-800 w-10 text-center">128</span>
                        </div>
                    </div>
                    <div id="colorDisplay" class="sim-area flex items-center justify-center text-white text-2xl font-bold" style="background-color: rgb(128, 128, 128);">
                        RGB(128, 128, 128)
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 8: CAESAR CIPHER ENCRYPTION (CS/Math) -->
        <!-- ========================================================================================= -->
        <div id="game-cipher" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Caesar Cipher Encryption<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Cryptography Basics</h3>
                    <p class="text-gray-700 mb-4">The Caesar Cipher is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet.</p>
                    <p class="text-gray-700 mb-4">This fixed number is the Shift Key. Mathematically, this is a form of modular arithmetic (e.g., if you shift 'Z' by 1, you wrap around to 'A').</p>
                    <p class="text-gray-700">Enter a message and choose a shift value to encrypt it. The key (shift) determines how secure the message is.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="cipher-text" class="text-sm font-semibold text-gray-700">Plain Text (A-Z):</label>
                        <input type="text" id="cipher-text" value="HELLO WORLD" class="p-2 border border-gray-300 rounded-md text-center uppercase">
                        
                        <div class="flex items-center gap-4 justify-between">
                            <label for="cipher-shift" class="text-sm font-semibold text-gray-700">Shift Key (1-25):</label>
                            <input type="number" id="cipher-shift" min="1" max="25" value="3" class="w-16 p-2 border border-gray-300 rounded-md text-center">
                            <button onclick="applyCipher()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Encrypt
                            </button>
                        </div>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Cipher Text:</p>
                        <p id="cipher-output" class="text-xl font-mono text-red-600 break-all">KHOOR ZRUOG</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 9: UNIT CONVERSION CHALLENGE (Math/Science) -->
        <!-- ========================================================================================= -->
        <div id="game-unit" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Unit Conversion Challenge<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Metric System Mastery</h3>
                    <p class="text-gray-700 mb-4">The ability to convert units is essential in all fields of science and engineering. Conversions rely on knowing the proper conversion factor (ratio) between two units.</p>
                    <p class="text-gray-700 mb-4">For example, to convert from meters (m) to kilometers (km), you use the factor 1000 m = 1 km.</p>
                    <p class="text-gray-700">Select the initial unit, enter a value, and select the target unit. The calculator handles common length, mass, and time conversions (e.g., km to miles, kg to lbs, hours to seconds).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-3 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700">Value:</label>
                            <input type="number" id="unit-value" value="10" class="w-20 text-center">
                            <select id="unit-from" class="flex-grow">
                                <option value="km">Kilometers (km)</option>
                                <option value="m">Meters (m)</option>
                                <option value="mi">Miles (mi)</option>
                                <option value="kg">Kilograms (kg)</option>
                            </select>
                        </div>
                        <div class="text-center font-bold text-lg text-green-primary">TO</div>
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700">Target:</label>
                            <select id="unit-to" class="flex-grow">
                                <option value="mi">Miles (mi)</option>
                                <option value="m">Meters (m)</option>
                                <option value="km">Kilometers (km)</option>
                                <option value="lb">Pounds (lb)</option>
                            </select>
                            <button onclick="convertUnit()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Convert
                            </button>
                        </div>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Result:</p>
                        <p id="unit-output" class="text-xl font-mono text-red-600 break-all">6.21 mi</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 10: SIMPLE HARMONIC MOTION SIMULATOR (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-shm" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Simple Harmonic Motion (SHM)<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Oscillations and Waves</h3>
                    <p class="text-gray-700 mb-4">Simple Harmonic Motion (SHM) is the oscillatory motion of a system where the restoring force is directly proportional to the displacement. A classic example is a mass attached to a spring.</p>
                    <p class="text-gray-700 mb-4">The Period (time for one full cycle) and Frequency (cycles per second) are constant. The motion follows a sine wave pattern.</p>
                    <p class="text-gray-700">Adjust the Mass and Spring Constant (k) to see how the period of the oscillation changes. Higher mass slows the motion; stiffer spring (higher k) speeds it up.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div>
                            <label for="shm-mass" class="text-sm font-semibold text-gray-700">Mass (kg):</label>
                            <input type="range" id="shm-mass" min="1" max="10" value="5" oninput="updateShm(true)" class="w-20">
                        </div>
                        <div>
                            <label for="shm-k" class="text-sm font-semibold text-gray-700">Spring K:</label>
                            <input type="range" id="shm-k" min="1" max="10" value="5" oninput="updateShm(true)" class="w-20">
                        </div>
                        <button onclick="updateShm(true)" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Apply Settings
                        </button>
                    </div>
                    <canvas id="shmCanvas" class="sim-area"></canvas>
                    <div id="shmMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Period: 2.81 s. Frequency: 0.36 Hz.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 11: BINARY TO DECIMAL CONVERTER (CS/Math) -->
        <!-- ========================================================================================= -->
        <div id="game-binary" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Binary to Decimal Converter<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Number Systems</h3>
                    <p class="text-gray-700 mb-4">Computers operate using the Binary System (base-2), which only uses the digits 0 and 1. Humans typically use the Decimal System (base-10).</p>
                    <p class="text-gray-700 mb-4">Each digit in a binary number represents a power of two: ..., 16, 8, 4, 2, 1. To convert, you multiply the binary digit by its corresponding power of two and sum the results.</p>
                    <p class="text-gray-700">Enter an 8-bit binary string (e.g., 10101010) and calculate its decimal equivalent. The maximum value for 8 bits is 255.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="binary-input" class="text-sm font-semibold text-gray-700">Binary Input (up to 8 bits):</label>
                        <input type="text" id="binary-input" value="10101010" maxlength="8" class="p-2 border border-gray-300 rounded-md text-center font-mono text-2xl" placeholder="e.g., 10101010">
                        <button onclick="convertToDecimal()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Convert to Decimal
                        </button>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Decimal Value:</p>
                        <p id="decimal-output" class="text-3xl font-extrabold text-red-600">170</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 12: PRIME NUMBER TESTER (Math) -->
        <!-- ========================================================================================= -->
        <div id="game-prime" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Prime Number Tester<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Number Theory</h3>
                    <p class="text-gray-700 mb-4">A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself (e.g., 2, 3, 5, 7, 11...).</p>
                    <p class="text-gray-700 mb-4">Numbers that are not prime are called composite (e.g., 4, 6, 8, 9, 10...). The number 1 is neither prime nor composite.</p>
                    <p class="text-gray-700">Enter an integer to instantly check if it is prime. The algorithm checks for divisibility up to the square root of the number for efficiency.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="prime-input" class="text-sm font-semibold text-gray-700">Integer to Test (>= 2):</label>
                        <div class="flex items-center gap-4">
                            <input type="number" id="prime-input" value="17" min="2" class="p-2 border border-gray-300 rounded-md text-center font-mono text-2xl flex-grow">
                            <button onclick="checkPrime()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Test
                            </button>
                        </div>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Result:</p>
                        <p id="prime-output" class="text-2xl font-extrabold text-green-primary">17 is a Prime Number.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 13: SIMPLE ELECTRIC CIRCUIT SIMULATOR (Engineering/Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-circuit" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Simple Electric Circuit Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Ohm's Law</h3>
                    <p class="text-gray-700 mb-4">A simple circuit consists of a power source (Voltage), a component that restricts current (Resistance), and the flow of charge (Current).</p>
                    <p class="text-gray-700 mb-4">These three quantities are related by Ohm's Law: Voltage (V) = Current (I) * Resistance (R).</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        V = I * R
                    </div>
                    <p class="text-gray-700">Adjust the Voltage (V) and Resistance (R) to calculate the resulting Current (I) in the circuit, measured in Amperes.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex items-center gap-2 justify-between">
                            <label for="voltage-input" class="text-sm font-semibold text-gray-700">Voltage (V):</label>
                            <input type="number" id="voltage-input" value="12" min="1" class="w-20 text-center">
                        </div>
                        <div class="flex items-center gap-2 justify-between">
                            <label for="resistance-input" class="text-sm font-semibold text-gray-700">Resistance (R):</label>
                            <input type="number" id="resistance-input" value="4" min="0.1" step="0.1" class="w-20 text-center">
                        </div>
                        <button onclick="calculateOhm()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Calculate Current (I)
                        </button>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Calculated Current (I):</p>
                        <p id="current-output" class="text-3xl font-extrabold text-red-600">3.0 Amperes</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 14: pH LEVEL CALCULATOR (Chemistry) -->
        <!-- ========================================================================================= -->
        <div id="game-ph" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                pH Level Calculator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Acids and Bases</h3>
                    <p class="text-gray-700 mb-4">The pH scale measures the acidity or basicity of an aqueous solution. It ranges from 0 to 14. A pH of 7 is neutral (pure water), below 7 is acidic, and above 7 is basic (alkaline).</p>
                    <p class="text-gray-700 mb-4">pH is defined as the negative logarithm (base 10) of the hydrogen ion concentration (in moles per liter, M): pH = -log([H+]).</p>
                    <p class="text-gray-700">Enter the hydrogen ion concentration, and the calculator will determine the pH and classify the solution.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="hplus-input" class="text-sm font-semibold text-gray-700">Hydrogen Ion Concentration [H+] (e.g., 0.001 M):</label>
                        <input type="number" id="hplus-input" value="0.0001" step="0.00001" min="0.00000000000001" class="p-2 border border-gray-300 rounded-md text-center font-mono text-xl">
                        <button onclick="calculatePh()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Calculate pH
                        </button>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">pH Result:</p>
                        <p id="ph-output" class="text-3xl font-extrabold text-red-600">4.0 (Acidic)</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 15: VECTOR ADDITION CALCULATOR (Math/Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-vector" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Vector Addition Calculator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Vector Mathematics</h3>
                    <p class="text-gray-700 mb-4">A vector is a quantity that has both magnitude (size) and direction (e.g., velocity, force). Vectors in 2D space are represented by components (x, y).</p>
                    <p class="text-gray-700 mb-4">Vector Addition involves adding the corresponding components: (V<sub>1x</sub> + V<sub>2x</sub>, V<sub>1y</sub> + V<sub>2y</sub>). The resulting vector is the Resultant Force.</p>
                    <p class="text-gray-700">Enter the x and y components for two vectors (V<sub>1</sub> and V<sub>2</sub>). The calculator will find the components and the magnitude of the Resultant Vector (R).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex justify-between items-center"><span class="font-bold">Vector 1 (V<sub>1</sub>)</span> X: <input type="number" id="v1x" value="3" class="w-16 text-center"> Y: <input type="number" id="v1y" value="4" class="w-16 text-center"></div>
                        <div class="flex justify-between items-center"><span class="font-bold">Vector 2 (V<sub>2</sub>)</span> X: <input type="number" id="v2x" value="-1" class="w-16 text-center"> Y: <input type="number" id="v2y" value="2" class="w-16 text-center"></div>
                        <button onclick="addVectors()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Calculate Resultant
                        </button>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Resultant Vector (R):</p>
                        <p id="vector-r" class="text-xl font-mono text-red-600">R = (2, 6)</p>
                        <p class="mt-2 text-lg font-semibold text-gray-700 mb-2">Magnitude (|R|):</p>
                        <p id="vector-mag" class="text-xl font-mono text-red-600">6.32</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 16: OCEAN CURRENT SIMULATOR (Science/Earth Science) -->
        <!-- ========================================================================================= -->
        <div id="game-ocean" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Ocean Current Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Ocean Circulation Drivers</h3>
                    <p class="text-gray-700 mb-4">Ocean currents are driven by wind, water density differences (temperature and salinity), and topography (the shape of the ocean floor).</p>
                    <p class="text-gray-700 mb-4">
                        <strong>1. Wind-Driven Currents:</strong> Surface winds push the water. The slider controls speed and direction (positive for East, negative for West).
                        <br>
                        <strong>2. Thermohaline Circulation:</strong> Density differences create a "conveyor belt." Cold, dense water sinks at the poles (top), and warm, less-dense water rises at the equator (bottom).
                        <br>
                        <strong>3. Topography:</strong> Landmasses and seamounts obstruct and redirect water flow, creating complex gyres and eddies.
                    </p>
                    <p class="text-gray-700">Adjust the sliders to see how these forces combine to create large-scale circular currents (gyres).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div>
                            <label for="ocean-wind" class="text-sm font-semibold text-gray-700">Wind (W/E):</label>
                            <input type="range" id="ocean-wind" min="-1" max="1" value="0.2" step="0.1" class="w-24">
                        </div>
                        <div>
                            <label for="ocean-heat" class="text-sm font-semibold text-gray-700">Equator Heat:</label>
                            <input type="range" id="ocean-heat" min="0" max="1" value="0.5" step="0.1" class="w-24">
                        </div>
                        <button onclick="initOceanSim()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Start/Reset
                        </button>
                        <button onclick="toggleLandmass()" id="landmass-toggle-btn" class="btn-action px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                            Landmass: ON
                        </button>
                    </div>
                    <canvas id="oceanCanvas" class="sim-area"></canvas>
                    <div id="oceanMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Adjust sliders and press Start.
                    </div>
                </div>
            </div>
        </div>

       

        <!-- ========================================================================================= -->
        <!-- GAME 17: STELLAR CLASSIFICATION (Science/Astronomy) -->
        <!-- ========================================================================================= -->
        <div id="game-star" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Stellar Classification<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Hertzsprung-Russell (H-R) Diagram</h3>
                    <p class="text-gray-700 mb-4">Stars are classified by their temperature (color) and luminosity (brightness/absolute magnitude). This system is summarized in the H-R Diagram.</p>
                    <p class="text-gray-700 mb-4">The spectral classes, from hottest to coldest, are O, B, A, F, G, K, M. Our Sun is a G-type star.</p>
                    <p class="text-gray-700">Select the temperature (color) and brightness of a star to determine its class and what stage of life it is currently in (e.g., Main Sequence, Red Giant, White Dwarf).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex justify-between items-center">
                            <label for="star-temp" class="text-sm font-semibold text-gray-700">Temperature (Color):</label>
                            <select id="star-temp" onchange="classifyStar()" class="w-32">
                                <option value="O">O (Blue, >25k K)</option>
                                <option value="G" selected>G (Yellow, 5k-6k K)</option>
                                <option value="M">M (Red, <3.5k K)</option>
                            </select>
                        </div>
                        <div class="flex justify-between items-center">
                            <label for="star-lum" class="text-sm font-semibold text-gray-700">Luminosity (Magnitude):</label>
                            <select id="star-lum" onchange="classifyStar()" class="w-32">
                                <option value="High">High</option>
                                <option value="Medium" selected>Medium</option>
                                <option value="Low">Low</option>
                            </select>
                        </div>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Classification:</p>
                        <p id="star-output" class="text-2xl font-extrabold text-green-primary">G2V (Main Sequence)</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 18: VOLUME CALCULATOR (Math) -->
        <!-- ========================================================================================= -->
        <div id="game-volume" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Volume Calculator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">3D Geometry</h3>
                    <p class="text-gray-700 mb-4">Volume is the amount of three-dimensional space occupied by an object. Calculating volume depends on the object's shape.</p>
                    <p class="text-gray-700 mb-4">For a Cube/Rectangular Prism, Volume = length x width x height. For a Sphere, Volume = 4/3  &pi; r<sup>3</sup>.</p>
                    <p class="text-gray-700">Select a 3D shape and enter the required dimensions (length, radius, etc.) to calculate its volume. All inputs are assumed to be in the same unit (e.g., cm).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="volume-shape" class="text-sm font-semibold text-gray-700">Select Shape:</label>
                        <select id="volume-shape" onchange="updateVolumeInputs()" class="p-2">
                            <option value="cube">Cube (Length, Width, Height)</option>
                            <option value="sphere">Sphere (Radius)</option>
                        </select>

                        <div id="volume-inputs" class="flex flex-wrap gap-2 justify-between">
                            <input type="number" id="vol-dim1" placeholder="Length" value="5" class="w-20 text-center">
                            <input type="number" id="vol-dim2" placeholder="Width" value="5" class="w-20 text-center">
                            <input type="number" id="vol-dim3" placeholder="Height" value="5" class="w-20 text-center">
                        </div>

                        <button onclick="calculateVolume()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Calculate Volume
                        </button>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Calculated Volume (units³):</p>
                        <p id="volume-output" class="text-3xl font-extrabold text-red-600">125.00</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 19: SIMPLE INVENTORY/STACK MANAGEMENT (CS) -->
        <!-- ========================================================================================= -->
        <div id="game-stack" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Simple Inventory (Stack)<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Data Structures (LIFO)</h3>
                    <p class="text-gray-700 mb-4">A Stack is a fundamental data structure that operates on the LIFO (Last-In, First-Out) principle, like a stack of plates. The last item added is the first item to be removed.</p>
                    <p class="text-gray-700 mb-4">Key operations are Push (add an item to the top) and Pop (remove the top item).</p>
                    <p class="text-gray-700">Use this simulator to manage a stack of items. Push items onto the stack and see how the Pop operation always retrieves the most recently added item.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col justify-center">
                    <div class="flex flex-col gap-4 p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="stack-input" class="text-sm font-semibold text-gray-700">Item to Push:</label>
                        <div class="flex items-center gap-2">
                            <input type="text" id="stack-input" value="Mug" class="p-2 border border-gray-300 rounded-md flex-grow">
                            <button onclick="pushStack()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                PUSH
                            </button>
                            <button onclick="popStack()" class="btn-action px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600">
                                POP
                            </button>
                        </div>
                    </div>
                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Current Stack (Top to Bottom):</p>
                        <div id="stack-display" class="min-h-24 bg-white p-2 border border-gray-300 rounded-md flex flex-col-reverse gap-1 items-center justify-start">
                            <span class="p-1 w-full text-center bg-gray-200 rounded text-sm">Plate 3</span>
                            <span class="p-1 w-full text-center bg-gray-200 rounded text-sm">Plate 2</span>
                            <span class="p-1 w-full text-center bg-gray-200 rounded text-sm">Plate 1</span>
                        </div>
                        <p id="stack-message" class="text-center mt-2 text-sm text-gray-600">Stack size: 3</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 20: FIBONACCI SEQUENCE CALCULATOR (Math/Computer Science) - ORIGINAL 4 MOVED TO 20 -->
        <!-- ========================================================================================= -->
        <div id="game-fibonacci" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Fibonacci Sequence Calculator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Sequence and Growth Rate</h3>
                    
                    <p class="text-gray-700 mb-4">The Fibonacci sequence, denoted Fn, is an infinite series of numbers where each number after the first two is the sum of the two preceding ones. The sequence starts with F0 = 0 and F1 = 1.</p>
                    
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        Fn = F(n-1) + F(n-2)
                    </div>
                    
                    <p class="text-gray-700 mb-4">The ratio of consecutive Fibonacci numbers converges to the Golden Ratio (approximately 1.618). This ratio is prevalent in nature, art, and architecture.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col items-center">
                    
                    <div class="controls flex gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <label for="fib-index" class="text-sm font-semibold text-gray-700">Calculate Index (N):</label>
                        <input type="number" id="fib-index" min="0" max="40" value="10" class="w-20 p-2 border border-gray-300 rounded-md text-center">
                        <button onclick="calculateFibonacci()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Calculate
                        </button>
                    </div>

                    <div class="w-full mt-4 p-4 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Result FN:</p>
                        <p id="fib-result" class="text-3xl font-extrabold text-red-600">55</p>
                        <p class="mt-4 text-sm font-semibold text-gray-700 mb-1">Sequence (up to N=10):</p>
                        <p id="fib-sequence" class="text-sm font-mono text-gray-600 break-all">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 21: FRICTION SIMULATOR (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-friction" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Friction Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Forces in Action</h3>
                    <p class="text-gray-700 mb-4">Friction is a force that opposes motion between surfaces in contact. There are two main types:</p>
                    <ul class="list-disc list-inside text-gray-700 mb-4">
                        <li><strong>Static Friction:</strong> The force that must be overcome to start moving an object.</li>
                        <li><strong>Kinetic Friction:</strong> The force that opposes an object already in motion. It's usually less than static friction.</li>
                    </ul>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        F<sub>friction</sub> &le; &mu; * F<sub>normal</sub>
                    </div>
                    <p class="text-gray-700">Adjust the applied force and surface type to see when the block starts to move and how fast it accelerates.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex flex-wrap gap-4 items-center justify-center">
                            <div>
                                <label for="friction-surface" class="text-sm font-semibold text-gray-700">Surface:</label>
                                <select id="friction-surface" class="p-2 border border-gray-300 rounded-md" onchange="resetFrictionSim()">
                                    <option value="ice">Ice (&mu;s=0.1, &mu;k=0.03)</option>
                                    <option value="wood" selected>Wood (&mu;s=0.4, &mu;k=0.2)</option>
                                    <option value="sandpaper">Sandpaper (&mu;s=0.9, &mu;k=0.7)</option>
                                </select>
                            </div>
                            <div class="flex items-center gap-2">
                                <label for="friction-force" class="text-sm font-semibold text-gray-700">Force (N):</label>
                                <input type="range" id="friction-force" min="0" max="100" value="0" step="1" class="w-24" oninput="updateFrictionForce()">
                                <span id="friction-force-val" class="font-bold text-green-primary w-10 text-center">0</span>
                            </div>
                        </div>
                        <div>
                            <button onclick="startFrictionSim()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Apply & Reset
                            </button>
                        </div>
                    </div>
                    <canvas id="frictionCanvas" class="sim-area"></canvas>
                    <div id="frictionMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Set a surface and apply force.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 22: ENERGY CONSERVATION SIMULATOR (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-energy" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Energy Conservation Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Potential & Kinetic Energy</h3>
                    <p class="text-gray-700 mb-4">The Principle of Conservation of Energy states that in an isolated system, the total energy remains constant. It can only be converted from one form to another.</p>
                    <ul class="list-disc list-inside text-gray-700 mb-4">
                        <li><strong>Potential Energy (PE):</strong> Stored energy due to an object's position. For a pendulum, it's highest at the peak of its swing. <br><code>PE = mgh</code></li>
                        <li><strong>Kinetic Energy (KE):</strong> Energy of motion. It's highest when the pendulum is moving fastest at the bottom of its swing. <br><code>KE = 0.5 * mv²</code></li>
                    </ul>
                    <p class="text-gray-700 mb-4">Watch how the energy transforms between PE and KE. In a perfect, isolated system, the total mechanical energy (PE + KE) would remain constant.</p>
                    <h4 class="text-lg font-bold text-green-primary mt-4 mb-2">Why Does It Stop? Energy Dissipation</h4>
                    <p class="text-gray-700">
                        In reality, energy is gradually lost from the system. This is called <strong>energy dissipation</strong>. In this simulation, it's caused by forces like air resistance and friction at the pivot. This dissipated energy (often as heat) causes the pendulum to slow down until it comes to rest at its lowest point - the <strong>equilibrium state</strong>.
                    </p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex items-center gap-2">
                            <label for="energy-mass" class="text-sm font-semibold text-gray-700">Mass (kg):</label>
                            <input type="range" id="energy-mass" min="1" max="10" value="5" step="1" class="w-24" oninput="resetEnergySim()">
                            <span id="energy-mass-val" class="font-bold text-green-primary w-10 text-center">5</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <label for="energy-angle" class="text-sm font-semibold text-gray-700">Angle (°):</label>
                            <input type="range" id="energy-angle" min="10" max="90" value="45" step="5" class="w-24" oninput="resetEnergySim()">
                            <span id="energy-angle-val" class="font-bold text-green-primary w-10 text-center">45</span>
                        </div>
                        <button onclick="startEnergySim()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                            Start/Reset
                        </button>
                    </div>
                    <canvas id="energyCanvas" class="sim-area"></canvas>
                    <div id="energyMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Adjust settings and press Start.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 23: DOPPLER EFFECT SIMULATOR (Physics/Sound) -->
        <!-- ========================================================================================= -->
        <div id="game-doppler" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Doppler Effect Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Wave Frequency and Motion</h3>
                    <p class="text-gray-700 mb-4">The Doppler effect is the change in frequency of a wave in relation to an observer who is moving relative to the wave source. It's why an ambulance siren sounds higher in pitch as it approaches you and lower as it moves away.</p>
                    <ul class="list-disc list-inside text-gray-700 mb-4">
                        <li><strong>Approaching:</strong> The sound waves are compressed, leading to a higher frequency (higher pitch).</li>
                        <li><strong>Receding:</strong> The sound waves are spread out, leading to a lower frequency (lower pitch).</li>
                    </ul>
                    <p class="text-gray-700">This effect applies to all waves, including light, where it's used in astronomy to determine the movement of stars (redshift/blueshift).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex items-center gap-2">
                            <label for="doppler-velocity" class="text-sm font-semibold text-gray-700">Source Velocity (m/s):</label>
                            <input type="range" id="doppler-velocity" min="-100" max="100" value="50" step="10" class="w-32">
                            <span id="doppler-velocity-val" class="font-bold text-green-primary w-12 text-center">50</span>
                        </div>
                        <div class="flex gap-2 justify-center">
                            <button onclick="startDopplerSim()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Start
                            </button>
                            <button onclick="stopDopplerSim()" class="btn-action px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600">
                                Stop
                            </button>
                        </div>
                    </div>
                    <canvas id="dopplerCanvas" class="sim-area"></canvas>
                    <div id="dopplerMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Adjust velocity and press Start. (Sound will play!)
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 24: CANTILEVER BEAM SIMULATOR (Engineering) -->
        <!-- ========================================================================================= -->
        <div id="game-cantilever" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Cantilever Beam Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Structural Engineering</h3>
                    <p class="text-gray-700 mb-4">A cantilever is a beam anchored at only one end. When a load is applied to the free end, the beam bends. This bending is called deflection.</p>
                    <p class="text-gray-700 mb-4">The amount of deflection depends on the beam's length, its material properties (Modulus of Elasticity, E), its cross-sectional shape (Moment of Inertia, I), and the applied load.</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        Deflection &prop; (Load * Length³) / (E * I)
                    </div>
                    <p class="text-gray-700">Adjust the parameters to see how they affect the beam's deflection. A longer beam or a heavier load will cause more bending, while a stiffer material will resist it.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24">Load (N):</label>
                            <input type="range" id="cantilever-load" min="10" max="200" step="10" value="50" class="flex-grow" oninput="drawCantilever()">
                            <span id="cantilever-load-val" class="font-bold text-green-primary w-12 text-center">50</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24">Length (m):</label>
                            <input type="range" id="cantilever-length" min="50" max="100" step="1" value="75" class="flex-grow" oninput="drawCantilever()">
                            <span id="cantilever-length-val" class="font-bold text-green-primary w-12 text-center">75</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24">Stiffness:</label>
                            <select id="cantilever-stiffness" class="flex-grow p-1 border border-gray-300 rounded-md" oninput="drawCantilever()">
                                <option value="1">Wood (Low)</option>
                                <option value="5" selected>Aluminum (Medium)</option>
                                <option value="15">Steel (High)</option>
                            </select>
                        </div>
                    </div>
                    <canvas id="cantileverCanvas" class="sim-area"></canvas>
                    <div id="cantileverMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Deflection: 0.00 mm
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 25: LEVER MECHANISM SIMULATOR (Physics/Engineering) -->
        <!-- ========================================================================================= -->
        <div id="game-lever" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Lever Mechanism Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Mechanical Advantage</h3>
                    <p class="text-gray-700 mb-4">A lever is a simple machine consisting of a beam or rigid rod pivoted at a fixed hinge, or fulcrum. It's used to lift heavy loads with less effort.</p>
                    <p class="text-gray-700 mb-4">The principle of the lever is based on balancing torques. The torque from the effort must equal the torque from the load.</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        Effort &times; Effort Arm = Load &times; Load Arm
                    </div>
                    <p class="text-gray-700">Move the fulcrum to see how the effort required to lift the 100kg load changes. Placing the fulcrum closer to the load gives you a greater <strong>mechanical advantage</strong>.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-32">Fulcrum Position:</label>
                            <input type="range" id="lever-fulcrum" min="10" max="90" step="1" value="50" class="flex-grow" oninput="drawLever()">
                            <span id="lever-fulcrum-val" class="font-bold text-green-primary w-12 text-center">50%</span>
                        </div>
                    </div>
                    <canvas id="leverCanvas" class="sim-area"></canvas>
                    <div id="leverMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Effort Required: 100.0 kg | Mechanical Advantage: 1.0x
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 25: INCLINED PLANE SIMULATOR (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-inclined-plane" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Inclined Plane Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Decomposition of Forces</h3>
                    <p class="text-gray-700 mb-4">An inclined plane is a simple machine that reduces the force needed to lift an object. It works by decomposing the force of gravity (mg) into two components:</p>
                    <ul class="list-disc list-inside text-gray-700 mb-4">
                        <li><strong>Normal Force (F<sub>N</sub>):</strong> Perpendicular to the surface, counteracted by the plane itself. <code>F<sub>N</sub> = mg cos(&theta;)</code></li>
                        <li><strong>Parallel Force (F<sub>P</sub>):</strong> Parallel to the surface, pulling the object down the slope. This is the force you must overcome. <code>F<sub>P</sub> = mg sin(&theta;)</code></li>
                    </ul>
                    <p class="text-gray-700 mb-4">The <strong>Net Force</strong> is the sum of all forces. If the applied force is greater than the forces pulling the block down the slope (parallel force + friction), the net force is positive, and the block accelerates up the ramp.</p>
                    <p class="text-gray-700">Notice how a smaller angle (&theta;) results in a smaller parallel force, making it easier to move the object.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24">Angle (&theta;):</label>
                            <input type="range" id="plane-angle" min="0" max="60" step="1" value="30" class="flex-grow" oninput="resetInclinedPlaneSim()">
                            <span id="plane-angle-val" class="font-bold text-green-primary w-12 text-center">30°</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24">Mass (kg):</label>
                            <input type="range" id="plane-mass" min="1" max="20" step="1" value="10" class="flex-grow" oninput="resetInclinedPlaneSim()">
                            <span id="plane-mass-val" class="font-bold text-green-primary w-12 text-center">10</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24">Friction (&mu;k):</label>
                            <input type="range" id="plane-friction" min="0" max="1" step="0.05" value="0.2" class="flex-grow" oninput="resetInclinedPlaneSim()">
                            <span id="plane-friction-val" class="font-bold text-green-primary w-12 text-center">0.20</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24">Applied Force (N):</label>
                            <input type="range" id="plane-force" min="0" max="200" step="1" value="0" class="flex-grow" oninput="resetInclinedPlaneSim()">
                            <span id="plane-force-val" class="font-bold text-green-primary w-12 text-center">0</span>
                        </div>
                        <button onclick="startInclinedPlaneSim()" class="btn-action mt-2 px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">Run Simulation</button>
                    </div>
                    <canvas id="inclinedPlaneCanvas" class="sim-area"></canvas>
                    <div id="inclinedPlaneMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Adjust the sliders to see the forces change.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 26: BUOYANCY SIMULATOR (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-buoyancy" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Buoyancy Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Archimedes' Principle</h3>
                    <p class="text-gray-700 mb-4">Buoyancy is the upward force exerted by a fluid that opposes the weight of a partially or fully immersed object. This is described by Archimedes' Principle.</p>
                    <p class="text-gray-700 mb-4">An object's fate in a fluid is determined by its density relative to the fluid's density.
                        <ul class="list-disc list-inside text-gray-700 my-2">
                            <li>If <strong>Object Density &lt; Fluid Density</strong>, the object floats.</li>
                            <li>If <strong>Object Density &gt; Fluid Density</strong>, the object sinks.</li>
                        </ul>
                    </p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        F<sub>buoyant</sub> = &rho;<sub>fluid</sub> &times; V<sub>submerged</sub> &times; g
                    </div>
                    <p class="text-gray-700">Adjust the densities to see this principle in action. Water has a density of 1000 kg/m³.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-32">Object Density (kg/m³):</label>
                            <input type="range" id="buoyancy-object-density" min="100" max="2000" step="10" value="500" class="flex-grow" oninput="drawBuoyancy()">
                            <span id="buoyancy-object-val" class="font-bold text-green-primary w-16 text-center">500</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-32">Fluid Density (kg/m³):</label>
                            <input type="range" id="buoyancy-fluid-density" min="500" max="1500" step="10" value="1000" class="flex-grow" oninput="drawBuoyancy()">
                            <span id="buoyancy-fluid-val" class="font-bold text-green-primary w-16 text-center">1000</span>
                        </div>
                    </div>
                    <canvas id="buoyancyCanvas" class="sim-area"></canvas>
                    <div id="buoyancyMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Status: Floating
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 27: INERTIA EXPLORER (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-inertia" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Inertia Explorer<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Newton's First Law of Motion</h3>
                    <p class="text-gray-700 mb-4">Inertia is the resistance of any physical object to any change in its state of motion. This is Newton's First Law: an object at rest stays at rest, and an object in motion stays in motion unless acted upon by an external force.</p>
                    <p class="text-gray-700 mb-4"><strong>Mass is a measure of inertia.</strong> The more mass an object has, the more it resists acceleration when a force is applied.</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        a = F / m
                    </div>
                    <p class="text-gray-700">Adjust the object's mass and apply a constant force. Notice how a larger mass results in a smaller change in velocity (lower acceleration).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700">Mass (kg):</label>
                            <input type="range" id="inertia-mass" min="10" max="100" step="5" value="50" class="w-32" oninput="resetInertiaSim()">
                            <span id="inertia-mass-val" class="font-bold text-green-primary w-12 text-center">50</span>
                        </div>
                        <div class="flex gap-2 justify-center">
                            <button onclick="applyInertiaForce()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Apply Force
                            </button>
                            <button onclick="resetInertiaSim()" class="btn-action px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                                Reset
                            </button>
                        </div>
                    </div>
                    <canvas id="inertiaCanvas" class="sim-area"></canvas>
                    <div id="inertiaMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Adjust mass and apply force.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 28: ROTATIONAL INERTIA RACE (Physics/Engineering) -->
        <!-- ========================================================================================= -->
        <div id="game-rotational-inertia" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Rotational Inertia Race<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Moment of Inertia</h3>
                    <p class="text-gray-700 mb-4">Rotational Inertia (or Moment of Inertia, I) is an object's resistance to being spun. It depends not just on the object's mass, but on how that mass is distributed relative to the axis of rotation.</p>
                    <p class="text-gray-700 mb-4">Objects with more mass further from the center are harder to spin. For a constant applied torque (&tau;), the angular acceleration (&alpha;) is given by &tau; = I&alpha;.</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        Disk: I = &frac12;MR&sup2; | Ring: I = MR&sup2;
                    </div>
                    <p class="text-gray-700">The disk and ring have the same mass and radius. Since the ring's mass is all at the edge, its rotational inertia is higher. Press "Start Race" to see which one accelerates faster!</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex gap-2 justify-center">
                            <button onclick="startRotationalInertiaRace()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Start Race
                            </button>
                            <button onclick="resetRotationalInertiaSim()" class="btn-action px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                                Reset
                            </button>
                        </div>
                    </div>
                    <canvas id="rotationalInertiaCanvas" class="sim-area"></canvas>
                    <div id="rotationalInertiaMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Press "Start Race" to apply torque.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 29: NEWTON'S THIRD LAW SIMULATOR (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-newton-third-law" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Newton's Third Law Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Action-Reaction Pairs</h3>
                    <p class="text-gray-700 mb-4">Newton's Third Law states that for every action, there is an equal and opposite reaction. This means that any force exerted by one object on another is paired with an equal force in the opposite direction from the second object on the first.</p>
                    <p class="text-gray-700 mb-4">While the forces are equal, the resulting accelerations are not, unless the masses are equal. This is described by the formula F = ma.</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        F<sub>AB</sub> = -F<sub>BA</sub> &nbsp;&nbsp;&rArr;&nbsp;&nbsp; m<sub>A</sub>a<sub>A</sub> = -m<sub>B</sub>a<sub>B</sub>
                    </div>
                    <p class="text-gray-700">Adjust the masses and trigger the interaction. Notice how the object with less mass accelerates much more quickly, even though the force is the same for both.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24 text-blue-500">Mass A (kg):</label>
                            <input type="range" id="newton-mass-a" min="10" max="100" step="5" value="20" class="flex-grow" oninput="resetNewtonThirdLawSim()">
                            <span id="newton-mass-a-val" class="font-bold text-green-primary w-12 text-center">20</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-24 text-red-500">Mass B (kg):</label>
                            <input type="range" id="newton-mass-b" min="10" max="100" step="5" value="80" class="flex-grow" oninput="resetNewtonThirdLawSim()">
                            <span id="newton-mass-b-val" class="font-bold text-green-primary w-12 text-center">80</span>
                        </div>
                        <div class="flex gap-2 justify-center mt-2">
                            <button onclick="triggerInteraction()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Trigger Interaction
                            </button>
                            <button onclick="resetNewtonThirdLawSim()" class="btn-action px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                                Reset
                            </button>
                        </div>
                    </div>
                    <canvas id="newtonThirdLawCanvas" class="sim-area"></canvas>
                    <div id="newtonThirdLawMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Adjust masses and trigger the interaction.
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 30: BERNOULLI'S PRINCIPLE SIMULATOR (Physics/Engineering) -->
        <!-- ========================================================================================= -->
        <div id="game-bernoulli" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Bernoulli's Principle Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Fluid Dynamics</h3>
                    <p class="text-gray-700 mb-4">Bernoulli's principle states that for an inviscid flow, an increase in the speed of the fluid occurs simultaneously with a decrease in pressure or a decrease in the fluid's potential energy. This is a statement of the conservation of energy for flowing fluids.</p>
                    <p class="text-gray-700 mb-4">This simulation shows the <strong>Venturi effect</strong>. As the fluid enters the constricted section of the pipe, it must speed up to maintain a constant flow rate (Continuity Equation: A₁v₁ = A₂v₂).</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        P + &frac12;&rho;v&sup2; = constant
                    </div>
                    <p class="text-gray-700">Adjust the pipe's constriction. Notice how the calculated pressure drops significantly where the velocity is highest, as shown in the values below the simulation.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-32">Constriction:</label>
                            <input type="range" id="bernoulli-constriction" min="20" max="100" step="5" value="50" class="flex-grow" oninput="drawBernoulli()">
                            <span id="bernoulli-constriction-val" class="font-bold text-green-primary w-12 text-center">50%</span>
                        </div>
                    </div>
                    <canvas id="bernoulliCanvas" class="sim-area"></canvas>
                    <div id="bernoulliMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        V₁: 1.0 m/s, P₁: 100 kPa | V₂: 2.0 m/s, P₂: 98.5 kPa
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 31: LIGHT REFRACTION & ABSORPTION (Physics) -->
        <!-- ========================================================================================= -->
        <div id="game-refraction" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Light Refraction & Absorption<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Optics and Snell's Law</h3>
                    <p class="text-gray-700 mb-4">Refraction is the bending of light as it passes from one medium to another. This happens because light travels at different speeds in different materials, which are characterized by a refractive index (n).</p>
                    <p class="text-gray-700 mb-4">The relationship between the angle of incidence (θ₁) and the angle of refraction (θ₂) is given by Snell's Law:</p>
                    <div class="bg-white p-3 rounded-lg shadow-md mb-4 text-center text-lg font-bold text-gray-900">
                        n₁ sin(θ₁) = n₂ sin(θ₂)
                    </div>
                    <p class="text-gray-700">If light travels from a denser to a less dense medium at a high enough angle, it can be completely reflected. This is called <strong>Total Internal Reflection</strong>. As light passes through a medium, some of it is also absorbed, reducing its intensity.</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-col gap-2 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-32">Angle of Incidence:</label>
                            <input type="range" id="refraction-angle" min="0" max="89" step="1" value="30" class="flex-grow" oninput="drawRefraction()">
                            <span id="refraction-angle-val" class="font-bold text-green-primary w-12 text-center">30°</span>
                        </div>
                        <div class="w-full flex items-center gap-2">
                            <label class="text-sm font-semibold text-gray-700 w-32">Bottom Medium:</label>
                            <select id="refraction-medium" class="flex-grow p-1 border border-gray-300 rounded-md" oninput="drawRefraction()">
                                <option value="1.33">Water (n=1.33)</option>
                                <option value="1.52" selected>Glass (n=1.52)</option>
                                <option value="2.42">Diamond (n=2.42)</option>
                            </select>
                        </div>
                    </div>
                    <canvas id="refractionCanvas" class="sim-area"></canvas>
                    <div id="refractionMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        θ₁: 30.0°, θ₂: 19.2°
                    </div>
                </div>
            </div>
        </div>

        <!-- ========================================================================================= -->
        <!-- GAME 32: LITHIUM-ION BATTERY SIMULATOR (Chemistry/Engineering) -->
        <!-- ========================================================================================= -->
        <div id="game-battery" class="game-card">
            <h2 class="text-3xl font-extrabold text-green-primary border-b-2 border-green-secondary pb-3 mb-6">
                Lithium-Ion Battery Simulator<sup>Copyright Maker Mindz</sup>
            </h2>

            <div class="game-grid">
                <div class="column-info info-panel flex-1 p-4 bg-green-light rounded-lg border border-green-secondary/50 shadow-inner">
                    <h3 class="text-xl font-bold text-green-primary mb-3 border-b border-green-primary/50 pb-2">Electrochemistry in Action</h3>
                    <p class="text-gray-700 mb-4">A Lithium-Ion battery generates electricity through the movement of lithium ions (Li+) and electrons. It consists of an Anode (typically graphite), a Cathode (e.g., Lithium Cobalt Oxide), and an electrolyte that allows ions to pass through.</p>
                    <ul class="list-disc list-inside text-gray-700 mb-4">
                        <li><strong>Discharging:</strong> Li+ ions move from the anode to the cathode through the electrolyte. Electrons move through the external circuit, powering a device (like the lightbulb).</li>
                        <li><strong>Charging:</strong> An external power source forces Li+ ions and electrons to move back from the cathode to the anode, storing energy for later use.</li>
                    </ul>
                    <p class="text-gray-700">Use the buttons to see this process in action. The simulation shows the flow of ions (blue dots) and electrons (yellow dots).</p>
                </div>
                
                <div class="column-controls flex-1 p-4 bg-white rounded-lg border border-gray-300 shadow-lg flex flex-col">
                    <div class="controls flex flex-wrap gap-4 items-center justify-center p-3 bg-gray-100 rounded-lg shadow-inner w-full mb-4">
                        <div class="flex gap-2 justify-center">
                            <button onclick="startBatteryDischarge()" class="btn-action px-4 py-2 bg-green-primary text-white rounded-lg hover:bg-green-secondary">
                                Discharge (Use)
                            </button>
                            <button onclick="startBatteryCharge()" class="btn-action px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600">
                                Charge
                            </button>
                            <button onclick="resetBatterySim()" class="btn-action px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
                                Reset
                            </button>
                        </div>
                    </div>
                    <canvas id="batteryCanvas" class="sim-area"></canvas>
                    <div id="batteryMessage" class="text-center mt-4 p-2 bg-blue-100 text-gray-800 font-semibold rounded-lg">
                        Battery is charged. Press Discharge to use.
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // =========================================================================================
        // SCRIPTS 1-20: GAME LOGIC
        // =========================================================================================

        // --- GLOBAL UTILITIES (for multiple games) ---
        function getCanvasContext(id) {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            // Set internal canvas resolution to match display size for crisp drawing
            canvas.width = width;
            canvas.height = height;
            return { ctx, width, height, canvas };
        }
        
        // --- GAME 1: LINEAR REGRESSION ---
        (function() {
            const DATA_POINTS = [
                {x: 1, y: 1.5}, {x: 2, y: 2.2}, {x: 3, y: 3.8}, {x: 4, y: 4.1}, 
                {x: 5, y: 5.5}, {x: 6, y: 6.0}, {x: 7, y: 7.9}, {x: 8, y: 8.1}
            ];
            const MAX_X = 10;
            const MAX_Y = 10;

            function toCanvasX(x, width) { return (x / MAX_X) * width; }
            function toCanvasY(y, height) { return height - (y / MAX_Y) * height; }

            window.updateRegressionPlot = function() {
                const { ctx, width, height } = getCanvasContext('regressionCanvas');
                const messageEl = document.getElementById('regressionMessage');

                const m = parseFloat(document.getElementById('slope').value) || 0;
                const b = parseFloat(document.getElementById('intercept').value) || 0;
                
                let sse = 0; 
                ctx.clearRect(0, 0, width, height);

                // 1. Draw Data Points
                ctx.fillStyle = '#27ae60';
                DATA_POINTS.forEach(p => {
                    const cx = toCanvasX(p.x, width);
                    const cy = toCanvasY(p.y, height);
                    ctx.beginPath();
                    ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Calculate Error for SSE
                    const predictedY = m * p.x + b;
                    sse += Math.pow(p.y - predictedY, 2);
                });

                // 2. Draw Regression Line (y = mx + b)
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                let yStart = m * 0 + b;
                ctx.moveTo(toCanvasX(0, width), toCanvasY(yStart, height));
                let yEnd = m * MAX_X + b;
                ctx.lineTo(toCanvasX(MAX_X, width), toCanvasY(yEnd, height));
                ctx.stroke();

                const roundedSSE = sse.toFixed(2);
                messageEl.textContent = `Current Model: y = ${m.toFixed(1)}x + ${b.toFixed(1)}. Sum of Squared Errors (SSE): ${roundedSSE}`;
                messageEl.className = 'text-center mt-4 p-2 bg-blue-100 text-blue-700 font-semibold rounded-lg';
            }

            window.addEventListener('load', window.updateRegressionPlot);
            window.addEventListener('resize', window.updateRegressionPlot);
        })();

        // --- GAME 2: QUADRATIC FUNCTION EXPLORER ---
        (function() {
            window.drawQuadratic = function() {
                const { ctx, width, height } = getCanvasContext('quadraticCanvas');
                const messageEl = document.getElementById('quadraticMessage');
                
                const a = parseFloat(document.getElementById('qa').value);
                const b = parseFloat(document.getElementById('qb').value);
                const c = parseFloat(document.getElementById('qc').value);

                document.getElementById('qa-val').textContent = a.toFixed(1);
                document.getElementById('qb-val').textContent = b.toFixed(1);
                document.getElementById('qc-val').textContent = c.toFixed(1);
                
                ctx.clearRect(0, 0, width, height);

                // Draw Axes (Center is x=0, y=0)
                const originX = width / 2;
                const originY = height / 2;
                const scale = width / 10; 
                
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, originY); ctx.lineTo(width, originY); // X-axis
                ctx.moveTo(originX, 0); ctx.lineTo(originX, height); // Y-axis
                ctx.stroke();

                // Draw Quadratic Curve
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();

                let first = true;
                let roots = [];
                for (let px = 0; px <= width; px++) {
                    const x = (px - originX) / scale;
                    const y = a * x * x + b * x + c;
                    const py = originY - y * scale;

                    if (first) {
                        ctx.moveTo(px, py);
                        first = false;
                    } else {
                        ctx.lineTo(px, py);
                    }

                    // Simple root finding (when y crosses 0)
                    if (py >= originY - 1 && py <= originY + 1 && x > -5 && x < 5) {
                        if (roots.length === 0 || Math.abs(x - roots[roots.length - 1]) > 0.1) {
                            roots.push(x);
                        }
                    }
                }
                ctx.stroke();

                // Calculate Vertex
                let vx = (a === 0) ? 0 : -b / (2 * a);
                let vy = a * vx * vx + b * vx + c;
                
                const vpx = originX + vx * scale;
                const vpy = originY - vy * scale;

                // Draw Vertex marker
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.arc(vpx, vpy, 4, 0, 2 * Math.PI);
                ctx.fill();

                // Update Message
                const rootText = (roots.length > 0) 
                    ? `Roots: ${roots[0].toFixed(2)}${roots.length > 1 ? ', ' + roots[1].toFixed(2) : ''}`
                    : 'No Real Roots';
                
                messageEl.textContent = `Vertex: (${vx.toFixed(2)}, ${vy.toFixed(2)}). ${rootText}.`;
                messageEl.className = 'text-center mt-4 p-2 bg-blue-100 text-blue-700 font-semibold rounded-lg';
            }

            window.addEventListener('load', window.drawQuadratic);
            window.addEventListener('resize', window.drawQuadratic);
        })();

        // --- GAME 3: HEAT TRANSFER SIMULATOR ---
        (function() {
            let temp1 = 80;
            let temp2 = 20;
            let animationFrameId;

            function drawHeatSim(ctx, width, height) {
                const color1 = `rgb(${255}, ${255 - temp1 * 2.5}, ${255 - temp1 * 2.5})`;
                const color2 = `rgb(${255 - temp2 * 2.5}, ${255 - temp2 * 2.5}, ${255})`;
                
                ctx.clearRect(0, 0, width, height);

                const blockWidth = width / 2;
                const blockHeight = height * 0.8;
                const yPos = (height - blockHeight) / 2;

                // Block 1 (Hot)
                ctx.fillStyle = color1;
                ctx.fillRect(0, yPos, blockWidth, blockHeight);
                ctx.strokeStyle = '#e74c3c';
                ctx.strokeRect(0, yPos, blockWidth, blockHeight);

                // Block 2 (Cold)
                ctx.fillStyle = color2;
                ctx.fillRect(blockWidth, yPos, blockWidth, blockHeight);
                ctx.strokeStyle = '#3498db';
                ctx.strokeRect(blockWidth, yPos, blockWidth, blockHeight);
                
                // Temps
                ctx.fillStyle = '#2c3e50';
                ctx.font = '20px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(`${temp1.toFixed(1)}°C`, blockWidth / 2, height / 2);
                ctx.fillText(`${temp2.toFixed(1)}°C`, blockWidth * 1.5, height / 2);

                document.getElementById('heatMessage').textContent = `Block 1 Temp: ${temp1.toFixed(1)}°C | Block 2 Temp: ${temp2.toFixed(1)}°C`;
            }

            function animateHeatSim() {
                const { ctx, width, height } = getCanvasContext('heatCanvas');
                const K = parseFloat(document.getElementById('conductivity').value);
                const dt = 0.05; 
                
                // Conduction model (simple proportional heat transfer)
                const dT = K * (temp1 - temp2) * dt;
                
                if (Math.abs(temp1 - temp2) > 0.1) {
                    temp1 -= dT;
                    temp2 += dT;
                    drawHeatSim(ctx, width, height);
                    animationFrameId = requestAnimationFrame(animateHeatSim);
                } else {
                    document.getElementById('heatMessage').textContent = `Equilibrium Reached at ${temp1.toFixed(1)}°C!`;
                }
            }

            window.resetHeatSim = function() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                temp1 = 80;
                temp2 = 20;
                const { ctx, width, height } = getCanvasContext('heatCanvas');
                drawHeatSim(ctx, width, height);
            }
            window.startHeatSim = function() {
                resetHeatSim();
                animateHeatSim();
            }

            window.addEventListener('load', window.resetHeatSim);
            window.addEventListener('resize', window.resetHeatSim);
        })();

        // --- GAME 4: DNA COMPLEMENT GENERATOR ---
        (function() {
            window.generateComplement = function() {
                const input = document.getElementById('dna-input').value.toUpperCase().trim();
                const outputEl = document.getElementById('dna-output');
                
                // Input validation (A, T, G, C only)
                if (!/^[ATGC]+$/.test(input)) {
                    outputEl.textContent = 'Invalid sequence. Use A, T, G, C only.';
                    outputEl.className = 'text-xl font-mono text-gray-500 break-all';
                    return;
                }

                let complement = '';
                for (let i = 0; i < input.length; i++) {
                    const base = input[i];
                    switch (base) {
                        case 'A': complement += 'T'; break;
                        case 'T': complement += 'A'; break;
                        case 'G': complement += 'C'; break;
                        case 'C': complement += 'G'; break;
                    }
                }
                outputEl.textContent = complement;
                outputEl.className = 'text-xl font-mono text-red-600 break-all';
            }

            window.addEventListener('load', window.generateComplement);
        })();

        // --- GAME 5: ARRAY SORTING CHALLENGE (Bubble Sort) ---
        (function() {
            let array = [];
            let i = 0; // Current pass index
            let j = 0; // Current comparison index
            let isSorted = false;

            function drawArray(ctx, width, height) {
                ctx.clearRect(0, 0, width, height);
                const barWidth = width / array.length;
                const maxVal = 50; 
                
                for (let k = 0; k < array.length; k++) {
                    const barHeight = (array[k] / maxVal) * height * 0.9;
                    const x = k * barWidth;
                    const y = height - barHeight;

                    // Color current comparison elements
                    if (!isSorted && k === j) {
                        ctx.fillStyle = '#e74c3c'; // Red for the comparison element
                    } else if (!isSorted && k === j + 1) {
                        ctx.fillStyle = '#f39c12'; // Orange for the next element
                    } else if (isSorted || k < i) {
                         ctx.fillStyle = '#2ecc71'; // Green for sorted (or passed)
                    } else {
                        ctx.fillStyle = '#3498db'; // Blue for unsorted
                    }
                    
                    ctx.fillRect(x, y, barWidth - 2, barHeight);
                    
                    // Draw number on the bar
                    ctx.fillStyle = 'black';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(array[k], x + barWidth / 2, y - 5);
                }
            }

            window.resetArray = function() {
                const { ctx, width, height } = getCanvasContext('sortCanvas');
                array = Array.from({ length: 15 }, () => Math.floor(Math.random() * 45) + 5);
                i = 0;
                j = 0;
                isSorted = false;
                document.getElementById('sortMessage').textContent = 'New array loaded. Start sorting!';
                drawArray(ctx, width, height);
            }

            window.sortStep = function() {
                const { ctx, width, height } = getCanvasContext('sortCanvas');
                
                if (isSorted || array.length <= 1) {
                    document.getElementById('sortMessage').textContent = 'The array is completely sorted!';
                    drawArray(ctx, width, height);
                    return;
                }

                if (i < array.length - 1) {
                    if (j < array.length - 1 - i) {
                        if (array[j] > array[j + 1]) {
                            // Swap
                            [array[j], array[j + 1]] = [array[j + 1], array[j]];
                            document.getElementById('sortMessage').textContent = `Swapped ${array[j+1]} and ${array[j]} at indices ${j} and ${j+1}.`;
                        } else {
                            document.getElementById('sortMessage').textContent = `No swap needed at indices ${j} and ${j+1}.`;
                        }
                        j++;
                    } else {
                        // End of a pass
                        i++;
                        j = 0;
                        document.getElementById('sortMessage').textContent = `Pass ${i} complete. Next pass starts.`;
                    }
                } else {
                    isSorted = true;
                    document.getElementById('sortMessage').textContent = 'The array is completely sorted!';
                }
                drawArray(ctx, width, height);
            }

            window.addEventListener('load', window.resetArray);
            window.addEventListener('resize', window.resetArray);
        })();

        // --- GAME 6: CENTER OF GRAVITY FINDER ---
        (function() {
            let masses = [];

            function drawCogSim(ctx, width, height) {
                ctx.clearRect(0, 0, width, height);
                let totalMass = 0;
                let sumMX = 0;
                let sumMY = 0;
                
                // Draw Masses
                masses.forEach(m => {
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    totalMass += m.mass;
                    sumMX += m.x * m.mass;
                    sumMY += m.y * m.mass;
                });
                
                // Calculate CoG
                let cogX = 0;
                let cogY = 0;
                if (totalMass > 0) {
                    cogX = sumMX / totalMass;
                    cogY = sumMY / totalMass;
                }

                // Draw CoG (Red Cross)
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cogX - 10, cogY);
                ctx.lineTo(cogX + 10, cogY);
                ctx.moveTo(cogX, cogY - 10);
                ctx.lineTo(cogX, cogY + 10);
                ctx.stroke();

                document.getElementById('cogMessage').textContent = `CoG: (X: ${cogX.toFixed(0)}, Y: ${cogY.toFixed(0)}). Total Masses: ${masses.length}`;
            }

            window.addMass = function(event) {
                const { ctx, width, height, canvas } = getCanvasContext('cogCanvas');
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // Simple fixed mass for all clicks
                masses.push({ x: x, y: y, mass: 1 });
                drawCogSim(ctx, width, height);
            }

            window.resetCogSim = function() {
                masses = [];
                const { ctx, width, height } = getCanvasContext('cogCanvas');
                drawCogSim(ctx, width, height);
            }

            window.addEventListener('load', window.resetCogSim);
            window.addEventListener('resize', window.resetCogSim);
        })();

        // --- GAME 7: COLOR THEORY MIXER ---
        (function() {
            window.updateColorMixer = function() {
                const r = parseInt(document.getElementById('colorR').value);
                const g = parseInt(document.getElementById('colorG').value);
                const b = parseInt(document.getElementById('colorB').value);
                
                document.getElementById('colorR-val').textContent = r;
                document.getElementById('colorG-val').textContent = g;
                document.getElementById('colorB-val').textContent = b;

                const colorString = `rgb(${r}, ${g}, ${b})`;
                const hexString = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
                
                const displayEl = document.getElementById('colorDisplay');
                displayEl.style.backgroundColor = colorString;
                displayEl.textContent = `RGB(${r}, ${g}, ${b}) / ${hexString}`;
            }
            window.addEventListener('load', window.updateColorMixer);
        })();

        // --- GAME 8: CAESAR CIPHER ENCRYPTION ---
        (function() {
            window.applyCipher = function() {
                const text = document.getElementById('cipher-text').value.toUpperCase();
                const shift = parseInt(document.getElementById('cipher-shift').value) % 26;
                let result = '';

                for (let i = 0; i < text.length; i++) {
                    let charCode = text.charCodeAt(i);
                    
                    // Check if it's an uppercase letter (A=65, Z=90)
                    if (charCode >= 65 && charCode <= 90) {
                        // Apply shift and wrap using modular arithmetic
                        charCode = charCode + shift;
                        if (charCode > 90) {
                            charCode -= 26;
                        }
                        result += String.fromCharCode(charCode);
                    } else {
                        // Keep non-alphabetic characters (like space) as they are
                        result += text[i];
                    }
                }
                document.getElementById('cipher-output').textContent = result;
            }
            window.addEventListener('load', window.applyCipher);
        })();

        // --- GAME 9: UNIT CONVERSION CHALLENGE ---
        (function() {
            const conversionFactors = {
                'km_m': 1000, 'm_km': 0.001,
                'km_mi': 0.621371, 'mi_km': 1.60934,
                'kg_lb': 2.20462, 'lb_kg': 0.453592,
            };

            window.convertUnit = function() {
                const value = parseFloat(document.getElementById('unit-value').value);
                const fromUnit = document.getElementById('unit-from').value;
                const toUnit = document.getElementById('unit-to').value;
                const outputEl = document.getElementById('unit-output');

                if (isNaN(value)) {
                    outputEl.textContent = 'Enter a valid number.';
                    return;
                }

                let result;
                const key = `${fromUnit}_${toUnit}`;

                if (fromUnit === toUnit) {
                    result = value;
                } else if (conversionFactors[key]) {
                    result = value * conversionFactors[key];
                } else {
                    // Fallback for missing or unsupported conversions
                    outputEl.textContent = 'Unsupported conversion.';
                    return;
                }

                outputEl.textContent = `${result.toFixed(2)} ${toUnit}`;
            }
            window.addEventListener('load', window.convertUnit);
        })();

        // --- GAME 10: SIMPLE HARMONIC MOTION SIMULATOR ---
        (function() {
            let lastTime = 0;
            let time = 0;
            let animationId;

            function updateShm(resetTime = false) {
                if (animationId) cancelAnimationFrame(animationId);
                if (resetTime) time = 0;
                
                const mass = parseFloat(document.getElementById('shm-mass').value);
                const k = parseFloat(document.getElementById('shm-k').value);
                
                const period = 2 * Math.PI * Math.sqrt(mass / k);
                const frequency = 1 / period;

                document.getElementById('shmMessage').textContent = `Period: ${period.toFixed(2)} s. Frequency: ${frequency.toFixed(2)} Hz.`;
                document.getElementById('shm-mass-val') ? document.getElementById('shm-mass-val').textContent = mass : null;
                document.getElementById('shm-k-val') ? document.getElementById('shm-k-val').textContent = k : null;
                
                animateShm(0); 
            }

            function animateShm(timestamp) {
                const { ctx, width, height } = getCanvasContext('shmCanvas');
                
                if (lastTime === 0) lastTime = timestamp;
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                time += deltaTime;

                const mass = parseFloat(document.getElementById('shm-mass').value);
                const k = parseFloat(document.getElementById('shm-k').value);
                const amplitude = (height / 2) * 0.8;
                const omega = Math.sqrt(k / mass); // Angular frequency

                ctx.clearRect(0, 0, width, height);

                // Draw Equilibrium Line
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // Calculate current displacement (x = A * cos(omega * t))
                const displacement = amplitude * Math.cos(omega * time);
                const cy = height / 2 - displacement;

                // Draw Spring (simplified)
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(width / 2, 0);
                ctx.lineTo(width / 2, cy - 20);
                ctx.stroke();

                // Draw Mass
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(width / 2, cy, 15, 0, 2 * Math.PI);
                ctx.fill();

                animationId = requestAnimationFrame(animateShm);
            }

            window.updateShm = updateShm;
            window.addEventListener('load', () => updateShm(true));
            window.addEventListener('resize', () => updateShm(false));
        })();


        // --- GAME 11: BINARY TO DECIMAL CONVERTER ---
        (function() {
            window.convertToDecimal = function() {
                const binary = document.getElementById('binary-input').value.trim();
                const outputEl = document.getElementById('decimal-output');
                
                if (!/^[01]+$/.test(binary)) {
                    outputEl.textContent = 'Invalid Binary';
                    outputEl.className = 'text-3xl font-extrabold text-gray-500';
                    return;
                }

                const decimal = parseInt(binary, 2);
                outputEl.textContent = decimal.toLocaleString();
                outputEl.className = 'text-3xl font-extrabold text-red-600';
            }
            window.addEventListener('load', window.convertToDecimal);
        })();

        // --- GAME 12: PRIME NUMBER TESTER ---
        (function() {
            function isPrime(num) {
                if (num <= 1) return false;
                if (num <= 3) return true;
                if (num % 2 === 0 || num % 3 === 0) return false;
                
                // Check up to sqrt(num)
                for (let i = 5; i * i <= num; i = i + 6) {
                    if (num % i === 0 || num % (i + 2) === 0) return false;
                }
                return true;
            }

            window.checkPrime = function() {
                const num = parseInt(document.getElementById('prime-input').value);
                const outputEl = document.getElementById('prime-output');
                
                if (isNaN(num) || num < 2) {
                    outputEl.textContent = 'Please enter an integer greater than 1.';
                    outputEl.className = 'text-2xl font-extrabold text-gray-500';
                    return;
                }

                if (isPrime(num)) {
                    outputEl.textContent = `${num} is a Prime Number.`;
                    outputEl.className = 'text-2xl font-extrabold text-green-primary';
                } else {
                    outputEl.textContent = `${num} is a Composite Number.`;
                    outputEl.className = 'text-2xl font-extrabold text-red-600';
                }
            }
            window.addEventListener('load', window.checkPrime);
        })();

        // --- GAME 13: SIMPLE ELECTRIC CIRCUIT SIMULATOR ---
        (function() {
            window.calculateOhm = function() {
                const V = parseFloat(document.getElementById('voltage-input').value);
                const R = parseFloat(document.getElementById('resistance-input').value);
                const outputEl = document.getElementById('current-output');

                if (isNaN(V) || isNaN(R) || R <= 0) {
                    outputEl.textContent = 'Invalid Input';
                    outputEl.className = 'text-3xl font-extrabold text-gray-500';
                    return;
                }
                
                const I = V / R; // I = V / R
                outputEl.textContent = `${I.toFixed(2)} Amperes`;
                outputEl.className = 'text-3xl font-extrabold text-red-600';
            }
            window.addEventListener('load', window.calculateOhm);
        })();

        // --- GAME 14: pH LEVEL CALCULATOR ---
        (function() {
            window.calculatePh = function() {
                const hPlus = parseFloat(document.getElementById('hplus-input').value);
                const outputEl = document.getElementById('ph-output');

                if (isNaN(hPlus) || hPlus <= 0) {
                    outputEl.textContent = 'Invalid Concentration';
                    outputEl.className = 'text-3xl font-extrabold text-gray-500';
                    return;
                }

                const pH = -Math.log10(hPlus);
                let classification;
                let color = 'text-yellow-500';

                if (pH < 7) {
                    classification = 'Acidic';
                    color = 'text-red-600';
                } else if (pH > 7) {
                    classification = 'Basic (Alkaline)';
                    color = 'text-blue-600';
                } else {
                    classification = 'Neutral';
                    color = 'text-green-primary';
                }
                
                outputEl.textContent = `${pH.toFixed(1)} (${classification})`;
                outputEl.className = `text-3xl font-extrabold ${color}`;
            }
            window.addEventListener('load', window.calculatePh);
        })();

        // --- GAME 15: VECTOR ADDITION CALCULATOR ---
        (function() {
            window.addVectors = function() {
                const v1x = parseFloat(document.getElementById('v1x').value);
                const v1y = parseFloat(document.getElementById('v1y').value);
                const v2x = parseFloat(document.getElementById('v2x').value);
                const v2y = parseFloat(document.getElementById('v2y').value);
                const rEl = document.getElementById('vector-r');
                const magEl = document.getElementById('vector-mag');

                if ([v1x, v1y, v2x, v2y].some(isNaN)) {
                    rEl.textContent = 'R = (Invalid Input, Invalid Input)';
                    magEl.textContent = 'Invalid Magnitude';
                    return;
                }

                const rx = v1x + v2x;
                const ry = v1y + v2y;
                const magnitude = Math.sqrt(rx * rx + ry * ry);
                
                rEl.textContent = `R = (${rx.toFixed(2)}, ${ry.toFixed(2)})`;
                magEl.textContent = magnitude.toFixed(2);
            }
            window.addEventListener('load', window.addVectors);
        })();

        // --- GAME 16: OCEAN CURRENT SIMULATOR ---
        (function() {
            let particles = [];
            let animationId;
            const NUM_PARTICLES = 300; // Increased particle count
            let topography = {};
            let isLandmassVisible = true;

            function drawOcean(ctx, width, height, topo) {
                // 1. Draw background (ocean)
                ctx.fillStyle = 'rgba(20, 40, 80, 0.9)';
                ctx.fillRect(0, 0, width, height);

                // Draw labels
                ctx.fillStyle = 'white';
                ctx.font = '14px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('Pole (Cold)', width / 2, 20);
                ctx.fillText('Equator (Warm)', width / 2, height / 2);
                ctx.fillText('Pole (Cold)', width / 2, height - 10);

                // 3. Draw Topography (landmass)
                if (isLandmassVisible && topo.path && topo.path.length > 1) {
                    ctx.fillStyle = '#7c6f64'; // Brownish color for land
                    ctx.strokeStyle = '#5d4a3c';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(topo.path[0].x, topo.path[0].y);
                    for (let i = 1; i < topo.path.length; i++) {
                        ctx.lineTo(topo.path[i].x, topo.path[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Add a label for the topography
                    ctx.fillStyle = 'white';
                    ctx.fillText('Landmass', width / 2, height / 2);
                }
            }

            function animateOcean() {
                const { ctx, width, height } = getCanvasContext('oceanCanvas');
                const wind = parseFloat(document.getElementById('ocean-wind').value);
                const heat = parseFloat(document.getElementById('ocean-heat').value);

                drawOcean(ctx, width, height, topography); // This call was duplicated, removing one.

                particles.forEach(p => {
                    // 1. Thermohaline effect (density) - Corrected for center equator
                    // `distFromEquator` is 0 at equator, 1 at poles.
                    const distFromEquator = Math.abs(p.y - height / 2) / (height / 2);
                    const heatForce = heat * (1 - distFromEquator) * 0.8; // Strongest at equator
                    const coldForce = -0.3 * distFromEquator; // Strongest at poles
                    p.vy += (p.y < height / 2) ? -heatForce : heatForce; // Push away from equator
                    p.vy += (p.y < height / 2) ? -coldForce : coldForce; // Pull toward poles

                    // Basic gyre formation
                    p.vx += (width / 2 - p.x) * 0.0001;

                    // 2. Wind effect (surface)
                    if (p.y < height * 0.3) {
                        p.vx += wind * 0.1;
                    }

                    // 3. Update position & apply friction
                    p.vx *= 0.95; p.vy *= 0.95;
                    p.x += p.vx; p.y += p.vy;
                    // 4. Collision with topography
                    if (isLandmassVisible && isPointInPolygon(p, topography.path)) {
                        p.x -= p.vx; // Revert position
                        p.y -= p.vy;
                        p.vx *= -0.5; // Bounce off with energy loss
                        p.vy *= -0.5;
                    }

                    // Ray-casting algorithm to check if a point is inside a polygon
                    function isPointInPolygon(point, polygon) {
                        if (!polygon || polygon.length === 0) return false;
                        let isInside = false;
                        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                            const xi = polygon[i].x, yi = polygon[i].y;
                            const xj = polygon[j].x, yj = polygon[j].y;
                            const intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                            if (intersect) isInside = !isInside;
                        }
                        return isInside;
                    }
                    // 5. Bounce off container walls
                    if (p.x < 0 || p.x > width) { p.vx *= -1; p.x = Math.max(0, Math.min(width, p.x)); }
                    if (p.y < 0 || p.y > height) { p.vy *= -1; p.y = Math.max(0, Math.min(height, p.y)); }

                    // Draw particle
                    // Simulate 3D: larger when warm/risen (closer to equator)
                    const size = 1 + (1 - distFromEquator) * 3;
                    ctx.fillStyle = distFromEquator > 0.5 ? '#aed6f1' : '#f5b7b1'; // Colder near poles, warmer near equator
                    ctx.fillRect(p.x, p.y, size, size);
                });

                animationId = requestAnimationFrame(animateOcean);
                document.getElementById('oceanMessage').textContent = 'Simulation running...';
            }

            window.toggleLandmass = function() {
                isLandmassVisible = !isLandmassVisible;
                const btn = document.getElementById('landmass-toggle-btn');
                btn.textContent = `Landmass: ${isLandmassVisible ? 'ON' : 'OFF'}`;
                btn.classList.toggle('bg-gray-500', isLandmassVisible);
                btn.classList.toggle('bg-red-500', !isLandmassVisible);
            }

            window.initOceanSim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                const { ctx, width, height } = getCanvasContext('oceanCanvas');

                // Define a more complex coastline shape
                topography = {
                    path: [
                        { x: width * 0.3, y: height * 0.3 },
                        { x: width * 0.7, y: height * 0.3 },
                        { x: width * 0.7, y: height * 0.7 },
                        { x: width * 0.5, y: height * 0.7 },
                        { x: width * 0.5, y: height * 0.5 },
                        { x: width * 0.3, y: height * 0.5 },
                    ]
                };

                particles = [];
                for (let i = 0; i < NUM_PARTICLES; i++) {
                    particles.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        vx: 0,
                        vy: 0
                    });
                }
                animateOcean();
            }

            window.addEventListener('load', () => {
                const { ctx, width, height } = getCanvasContext('oceanCanvas');
                drawOcean(ctx, width, height, {}); // Draw empty ocean initially
            });
            window.addEventListener('resize', () => {
                const { ctx, width, height } = getCanvasContext('oceanCanvas');
                drawOcean(ctx, width, height, {});
            });
        })();

        // --- GAME 17: STELLAR CLASSIFICATION ---
        (function() {
            window.classifyStar = function() {
                const temp = document.getElementById('star-temp').value;
                const lum = document.getElementById('star-lum').value;
                const outputEl = document.getElementById('star-output');

                let classification = '';
                let color = 'text-gray-700';

                // Simplified H-R Diagram Logic
                if (temp === 'O' && lum === 'High') {
                    classification = 'O Type (Main Sequence/Giant)';
                    color = 'text-blue-500';
                } else if (temp === 'G' && lum === 'Medium') {
                    classification = 'G Type (Main Sequence - Like the Sun)';
                    color = 'text-yellow-600';
                } else if (temp === 'M' && lum === 'Medium') {
                    classification = 'M Type (Main Sequence)';
                    color = 'text-red-600';
                } else if (temp === 'O' && lum === 'Low') {
                    classification = 'White Dwarf (Hot but Dim)';
                    color = 'text-blue-300';
                } else if (temp === 'M' && lum === 'High') {
                    classification = 'Red Giant/Supergiant (Cool but Bright)';
                    color = 'text-orange-500';
                } else {
                    classification = 'Main Sequence or other stage.';
                    color = 'text-green-primary';
                }

                outputEl.textContent = classification;
                outputEl.className = `text-2xl font-extrabold ${color}`;
            }
            window.addEventListener('load', window.classifyStar);
        })();

        // --- GAME 18: VOLUME CALCULATOR ---
        (function() {
            window.updateVolumeInputs = function() {
                const shape = document.getElementById('volume-shape').value;
                const inputsDiv = document.getElementById('volume-inputs');
                inputsDiv.innerHTML = '';

                if (shape === 'cube') {
                    inputsDiv.innerHTML = `
                        <input type="number" id="vol-dim1" placeholder="Length" value="5" class="w-20 text-center">
                        <input type="number" id="vol-dim2" placeholder="Width" value="5" class="w-20 text-center">
                        <input type="number" id="vol-dim3" placeholder="Height" value="5" class="w-20 text-center">
                    `;
                } else if (shape === 'sphere') {
                    inputsDiv.innerHTML = `
                        <input type="number" id="vol-dim1" placeholder="Radius" value="5" class="w-full text-center">
                    `;
                }
            }

            window.calculateVolume = function() {
                const shape = document.getElementById('volume-shape').value;
                const outputEl = document.getElementById('volume-output');
                let volume = 0;
                
                if (shape === 'cube') {
                    const l = parseFloat(document.getElementById('vol-dim1').value);
                    const w = parseFloat(document.getElementById('vol-dim2').value);
                    const h = parseFloat(document.getElementById('vol-dim3').value);
                    if (isNaN(l) || isNaN(w) || isNaN(h)) return;
                    volume = l * w * h;
                } else if (shape === 'sphere') {
                    const r = parseFloat(document.getElementById('vol-dim1').value);
                    if (isNaN(r)) return;
                    volume = (4 / 3) * Math.PI * Math.pow(r, 3);
                }

                outputEl.textContent = volume.toFixed(2);
                outputEl.className = 'text-3xl font-extrabold text-red-600';
            }
            window.addEventListener('load', () => { window.updateVolumeInputs(); window.calculateVolume(); });
        })();
        
        // --- GAME 19: SIMPLE INVENTORY/STACK MANAGEMENT ---
        (function() {
            let stack = ["Plate 1", "Plate 2", "Plate 3"];
            const displayEl = document.getElementById('stack-display');
            const messageEl = document.getElementById('stack-message');

            function renderStack() {
                displayEl.innerHTML = '';
                if (stack.length === 0) {
                    displayEl.innerHTML = '<p class="text-gray-400 text-sm italic">Stack is Empty</p>';
                } else {
                    stack.slice().reverse().forEach(item => { // Reverse for LIFO visual (top to bottom)
                        const itemEl = document.createElement('span');
                        itemEl.className = 'p-1 w-full text-center bg-gray-200 rounded text-sm shadow-md';
                        itemEl.textContent = item;
                        displayEl.appendChild(itemEl);
                    });
                }
                messageEl.textContent = `Stack size: ${stack.length}.`;
            }

            window.pushStack = function() {
                const inputEl = document.getElementById('stack-input');
                const item = inputEl.value.trim() || `Item ${stack.length + 1}`;
                if (stack.length >= 8) {
                    messageEl.textContent = `Stack is full! (Max 8 items).`;
                    return;
                }
                stack.push(item);
                inputEl.value = '';
                renderStack();
            }

            window.popStack = function() {
                if (stack.length > 0) {
                    const poppedItem = stack.pop();
                    messageEl.textContent = `POPPED: ${poppedItem}.`;
                } else {
                    messageEl.textContent = 'ERROR: Stack is empty. Cannot POP.';
                }
                renderStack();
            }
            window.addEventListener('load', renderStack);
        })();

        // --- GAME 20: FIBONACCI SEQUENCE CALCULATOR ---
        (function() {
            const resultEl = document.getElementById('fib-result');
            const sequenceEl = document.getElementById('fib-sequence');
            const indexInput = document.getElementById('fib-index');

            function fibonacci(n) {
                if (n < 0 || n > 40) return null; 
                if (n === 0) return 0;
                if (n === 1) return 1;

                let a = 0, b = 1, temp;
                let seq = [0, 1];

                for (let i = 2; i <= n; i++) {
                    temp = a + b;
                    a = b;
                    b = temp;
                    seq.push(temp);
                }
                return { value: b, sequence: seq };
            }

            window.calculateFibonacci = function() {
                const n = parseInt(indexInput.value);

                if (isNaN(n) || n < 0) {
                    resultEl.textContent = 'Invalid Index';
                    sequenceEl.textContent = 'N must be a non-negative integer.';
                    return;
                }
                if (n > 40) {
                    resultEl.textContent = 'Index Too High';
                    sequenceEl.textContent = 'Max index is 40 for quick calculation.';
                    return;
                }

                const result = fibonacci(n);
                if (result) {
                    resultEl.textContent = result.value.toLocaleString();
                    sequenceEl.textContent = result.sequence.join(', ');
                }
            }

            window.addEventListener('load', window.calculateFibonacci);
        })();

        // --- GAME 21: FRICTION SIMULATOR ---
        (function() {
            let animationId;
            let block = { x: 50, vx: 0, mass: 10 }; // mass in kg
            const g = 9.8; // gravity

            const surfaces = {
                ice: { static: 0.1, kinetic: 0.03, color: '#e0f7fa' },
                wood: { static: 0.4, kinetic: 0.2, color: '#d7ccc8' },
                sandpaper: { static: 0.9, kinetic: 0.7, color: '#a1887f' }
            };

            function drawFrictionSim(ctx, width, height, surface, appliedForce, frictionForce, status) {
                ctx.clearRect(0, 0, width, height);

                // Draw Surface
                const surfaceHeight = 50;
                ctx.fillStyle = surface.color;
                ctx.fillRect(0, height - surfaceHeight, width, surfaceHeight);
                ctx.strokeStyle = 'black';
                ctx.strokeRect(0, height - surfaceHeight, width, surfaceHeight);

                // Draw Block
                const blockHeight = 50;
                const blockWidth = 50;
                const blockY = height - surfaceHeight - blockHeight;
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(block.x, blockY, blockWidth, blockHeight);

                // Draw Force Arrows
                const arrowY = blockY + blockHeight / 2;
                // Applied Force
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(block.x + blockWidth, arrowY);
                ctx.lineTo(block.x + blockWidth + appliedForce, arrowY);
                ctx.stroke();
                // Friction Force
                ctx.strokeStyle = '#f39c12';
                ctx.beginPath();
                ctx.moveTo(block.x, arrowY);
                ctx.lineTo(block.x - frictionForce, arrowY);
                ctx.stroke();
            }

            function animateFriction() {
                const { ctx, width, height } = getCanvasContext('frictionCanvas');
                const surfaceType = document.getElementById('friction-surface').value;
                const appliedForce = parseFloat(document.getElementById('friction-force').value);
                const surface = surfaces[surfaceType];
                const normalForce = block.mass * g;
                const maxStaticFriction = surface.static * normalForce;
                const kineticFriction = surface.kinetic * normalForce;
                const messageEl = document.getElementById('frictionMessage');

                let frictionForce = 0;
                let acceleration = 0;
                let status = "Stationary";

                if (appliedForce > maxStaticFriction) {
                    // Moving
                    status = "Moving";
                    frictionForce = kineticFriction;
                    const netForce = appliedForce - frictionForce;
                    acceleration = netForce / block.mass;
                    block.vx += acceleration * 0.1; // dt = 0.1
                } else {
                    // Stationary
                    frictionForce = appliedForce; // Static friction matches applied force
                    block.vx = 0;
                }

                block.x += block.vx;

                // Stop if it hits the wall
                if (block.x > width - 50) {
                    const finalVelocity = block.vx; // Capture velocity before resetting
                    block.x = width - 50;
                    block.vx = 0;
                    cancelAnimationFrame(animationId);
                    messageEl.textContent = `Finished! Final Velocity: ${finalVelocity.toFixed(2)} m/s.`;
                    return;
                }

                drawFrictionSim(ctx, width, height, surface, appliedForce, frictionForce, status);
                messageEl.textContent = `Status: ${status} | Accel: ${acceleration.toFixed(2)} m/s² | Friction: ${frictionForce.toFixed(1)} N`;
                animationId = requestAnimationFrame(animateFriction);
            }

            window.updateFrictionForce = function() {
                document.getElementById('friction-force-val').textContent = document.getElementById('friction-force').value;
            }

            window.resetFrictionSim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                block.x = 50;
                block.vx = 0;
                const { ctx, width, height } = getCanvasContext('frictionCanvas');
                drawFrictionSim(ctx, width, height, surfaces.wood, 0, 0, "Ready");
                document.getElementById('frictionMessage').textContent = 'Set a surface and apply force.';
            }

            window.startFrictionSim = function() {
                resetFrictionSim();
                animateFriction();
            }

            window.addEventListener('load', window.resetFrictionSim);
            window.addEventListener('resize', window.resetFrictionSim);
        })();

        // --- GAME 22: ENERGY CONSERVATION SIMULATOR ---
        (function() {
            let animationId;
            let initialTotalEnergy = 0; // Store the initial energy for consistent bar scaling
            const g = 9.8; // gravity
            let pendulum = {
                angle: Math.PI / 4,
                angularVelocity: 0,
                length: 150, // pixels
                mass: 5,
                x: 0,
                y: 0
            };

            function drawEnergySim(ctx, width, height, pe, ke) {
                ctx.clearRect(0, 0, width, height);
                const pivotX = width / 2;
                const pivotY = 50;

                // Calculate bob position
                pendulum.x = pivotX + pendulum.length * Math.sin(pendulum.angle);
                pendulum.y = pivotY + pendulum.length * Math.cos(pendulum.angle);

                // Draw pendulum arm
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pivotX, pivotY);
                ctx.lineTo(pendulum.x, pendulum.y);
                ctx.stroke();

                // Draw pivot
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(pivotX, pivotY, 5, 0, 2 * Math.PI);
                ctx.fill();

                // Draw bob
                ctx.fillStyle = '#c0392b';
                ctx.beginPath();
                ctx.arc(pendulum.x, pendulum.y, pendulum.mass * 2, 0, 2 * Math.PI);
                ctx.fill();

                // Draw Energy Bars
                const barWidth = 20;
                const maxEnergy = initialTotalEnergy > 0 ? initialTotalEnergy : 1; // Use the initial energy as the max
                // Potential Energy Bar (Blue)
                const peHeight = (pe / maxEnergy) * (height * 0.4);
                ctx.fillStyle = '#3498db';
                ctx.fillRect(20, height - peHeight, barWidth, peHeight);
                ctx.fillText('PE', 20 + barWidth/2, height - peHeight - 5);

                // Kinetic Energy Bar (Green)
                const keHeight = (ke / maxEnergy) * (height * 0.4);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(50, height - keHeight, barWidth, keHeight);
                ctx.fillText('KE', 50 + barWidth/2, height - keHeight - 5);
            }

            function animateEnergy() {
                const { ctx, width, height } = getCanvasContext('energyCanvas');
                const messageEl = document.getElementById('energyMessage');

                // Physics Update
                const angularAcceleration = (-g / pendulum.length) * Math.sin(pendulum.angle);
                pendulum.angularVelocity += angularAcceleration * 0.016; // dt
                pendulum.angularVelocity *= 0.999; // Dampening
                pendulum.angle += pendulum.angularVelocity * 0.016;

                // Energy Calculation
                const h = pendulum.length * (1 - Math.cos(pendulum.angle));
                const v = pendulum.length * pendulum.angularVelocity;
                const pe = pendulum.mass * g * h;
                const ke = 0.5 * pendulum.mass * v * v;
                const totalEnergy = pe + ke;

                // Stop if energy is negligible
                if (totalEnergy < 0.01) {
                    return resetEnergySim(true); // Call reset and stop
                }

                drawEnergySim(ctx, width, height, pe, ke);
                messageEl.textContent = `PE: ${pe.toFixed(1)} J | KE: ${ke.toFixed(1)} J | Total: ${totalEnergy.toFixed(1)} J`;

                animationId = requestAnimationFrame(animateEnergy);
            }

            window.resetEnergySim = function(isFinalStop = false) {
                if (animationId) cancelAnimationFrame(animationId);
                
                const mass = parseFloat(document.getElementById('energy-mass').value);
                const angleDeg = parseFloat(document.getElementById('energy-angle').value);
                document.getElementById('energy-mass-val').textContent = mass;
                document.getElementById('energy-angle-val').textContent = angleDeg;

                pendulum.mass = mass;
                pendulum.angle = angleDeg * (Math.PI / 180); // Convert to radians
                pendulum.angularVelocity = 0;

                const { ctx, width, height } = getCanvasContext('energyCanvas');
                const h = pendulum.length * (1 - Math.cos(pendulum.angle));
                initialTotalEnergy = pendulum.mass * g * h; // Set the initial energy here

                if (isFinalStop) {
                    drawEnergySim(ctx, width, height, 0, 0);
                    document.getElementById('energyMessage').textContent = 'Pendulum at rest. PE: 0.0 J | KE: 0.0 J';
                } else {
                    drawEnergySim(ctx, width, height, initialTotalEnergy, 0);
                    document.getElementById('energyMessage').textContent = 'Adjust settings and press Start.';
                }
            }

            window.startEnergySim = function() {
                resetEnergySim();
                animateEnergy();
            }

            window.addEventListener('load', window.resetEnergySim);
            window.addEventListener('resize', window.resetEnergySim);
        })();

        // --- GAME 23: DOPPLER EFFECT SIMULATOR ---
        (function() {
            let animationId;
            let isRunning = false;
            let source = { x: 0, y: 0, vx: 50 };
            let observer = { x: 0, y: 0 };
            let waves = [];
            let frameCount = 0;
            let sound, lfo;
            const V_SOUND = 343; // Speed of sound in m/s
            const BASE_FREQ = 440; // A4 note

            function drawDopplerSim(ctx, width, height) {
                ctx.clearRect(0, 0, width, height);

                // Draw Observer (a person icon)
                ctx.fillStyle = '#34495e';
                ctx.beginPath();
                ctx.arc(observer.x, observer.y, 8, 0, 2 * Math.PI); // Head
                ctx.fillRect(observer.x - 4, observer.y + 8, 8, 15); // Body
                ctx.fillText('Observer', observer.x, observer.y + 35);

                // Draw Waves
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
                ctx.lineWidth = 2;
                waves.forEach(wave => {
                    ctx.beginPath();
                    ctx.arc(wave.x, wave.y, wave.r, 0, 2 * Math.PI);
                    ctx.stroke();
                });

                // Draw Source (an "ambulance")
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(source.x - 20, source.y - 10, 40, 20);
                ctx.fillStyle = '#ecf0f1';
                ctx.fillRect(source.x - 15, source.y - 8, 30, 10);
                ctx.fillStyle = '#3498db';
                ctx.fillRect(source.x - 2, source.y - 15, 4, 5); // Siren light
            }

            function animateDoppler() {
                const { ctx, width, height } = getCanvasContext('dopplerCanvas');
                const messageEl = document.getElementById('dopplerMessage');
                source.vx = parseFloat(document.getElementById('doppler-velocity').value);
                document.getElementById('doppler-velocity-val').textContent = source.vx;

                frameCount++;
                // Update source position
                source.x += source.vx * 0.016; // Scale velocity for animation

                // Emit a new wave periodically
                if (frameCount % 10 === 0) {
                    waves.push({ x: source.x, y: source.y, r: 0 });
                }

                // Expand waves and remove old ones
                waves.forEach(wave => wave.r += V_SOUND * 0.016);
                waves = waves.filter(wave => wave.r < width);

                // Calculate Perceived Frequency
                const v_source = source.vx;
                const perceivedFreq = BASE_FREQ * (V_SOUND / (V_SOUND - v_source));
                
                // Update sound pitch
                if (sound) {
                    sound.frequency.value = perceivedFreq;
                }

                // Reset if source goes off-screen
                if (source.x > width + 30) { // Gone off the right side
                    source.x = -30; // Reappear on the left
                } else if (source.x < -30) { // Gone off the left side
                    source.x = width + 30; // Reappear on the right
                }

                drawDopplerSim(ctx, width, height);
                messageEl.textContent = `Perceived Frequency: ${perceivedFreq.toFixed(0)} Hz`;
                animationId = requestAnimationFrame(animateDoppler);
            }

            window.resetDopplerSim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                isRunning = false;
                if (sound) {
                    sound.stop();
                    lfo.stop();
                }
                waves = [];
                frameCount = 0;
                const { ctx, width, height } = getCanvasContext('dopplerCanvas');
                source.x = -30;
                source.y = height / 2;
                observer.x = width / 2;
                observer.y = height * 0.75;
                drawDopplerSim(ctx, width, height);
                document.getElementById('dopplerMessage').textContent = 'Adjust velocity and press Start. (Sound will play!)';
            }

            window.startDopplerSim = async function() {
                if (isRunning) return; // Don't start if already running
                isRunning = true;

                await Tone.start(); // Required for audio to play after user interaction
                if (!sound) { // Create sound nodes only if they don't exist
                    sound = new Tone.Oscillator(BASE_FREQ, "sine").toDestination();
                    lfo = new Tone.LFO("4hz", -10, 10).connect(sound.detune);
                }
                sound.start();
                lfo.start();
                animateDoppler();
            }

            window.stopDopplerSim = function() {
                if (!isRunning) return;
                isRunning = false;
                cancelAnimationFrame(animationId);
                if (sound) sound.stop();
                if (lfo) lfo.stop();
            }

            window.addEventListener('load', window.resetDopplerSim);
            window.addEventListener('resize', window.resetDopplerSim);
        })();

        // --- GAME 24: CANTILEVER BEAM SIMULATOR ---
        (function() {
            window.drawCantilever = function() {
                const { ctx, width, height } = getCanvasContext('cantileverCanvas');
                const messageEl = document.getElementById('cantileverMessage');

                const load = parseFloat(document.getElementById('cantilever-load').value);
                const lengthPercent = parseFloat(document.getElementById('cantilever-length').value);
                const stiffness = parseFloat(document.getElementById('cantilever-stiffness').value);

                document.getElementById('cantilever-load-val').textContent = load;
                document.getElementById('cantilever-length-val').textContent = lengthPercent;

                ctx.clearRect(0, 0, width, height);

                const wallWidth = 20;
                const beamThickness = 15;
                const beamY = height / 2;
                const beamLength = (lengthPercent / 100) * (width - wallWidth - 30);

                // Simplified deflection formula (not to scale, but proportional)
                // Deflection is proportional to (Load * Length^3) / Stiffness
                const deflection = (load * Math.pow(beamLength, 3)) / (stiffness * 1e8); // 1e8 is a scaling factor

                // 1. Draw Wall
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(0, 0, wallWidth, height);

                // 2. Draw Deflected Beam (as a quadratic curve)
                ctx.beginPath();
                ctx.moveTo(wallWidth, beamY);
                // Control point for curve is halfway along length, and a fraction of total deflection down
                ctx.quadraticCurveTo(wallWidth + beamLength / 2, beamY + deflection * 0.5, wallWidth + beamLength, beamY + deflection);
                ctx.lineTo(wallWidth + beamLength, beamY + deflection - beamThickness);
                ctx.quadraticCurveTo(wallWidth + beamLength / 2, beamY + deflection * 0.5 - beamThickness, wallWidth, beamY - beamThickness);
                ctx.closePath();
                ctx.fillStyle = '#34495e';
                ctx.fill();
                
                // 3. Draw Load Arrow
                const arrowX = wallWidth + beamLength;
                const arrowTipY = beamY + deflection - beamThickness; // Tip of the arrow on the beam's center
                const arrowLength = 10 + load / 5; // Make arrow length proportional to load
                const arrowStartY = arrowTipY - arrowLength; // Start of the arrow's shaft

                ctx.strokeStyle = '#e74c3c'; // Red color for the force arrow
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Draw the vertical shaft of the arrow
                ctx.moveTo(arrowX, arrowStartY);
                ctx.lineTo(arrowX, arrowTipY);
                // Draw the arrowhead pointing down
                ctx.moveTo(arrowX, arrowTipY);
                ctx.lineTo(arrowX - 5, arrowTipY - 5);
                ctx.moveTo(arrowX, arrowTipY);
                ctx.lineTo(arrowX + 5, arrowTipY - 5);
                ctx.stroke();

                // 4. Update Message
                messageEl.textContent = `Deflection: ${deflection.toFixed(2)} mm`;
            }

            window.addEventListener('load', window.drawCantilever);
            window.addEventListener('resize', window.drawCantilever);
        })();

        // --- GAME 25: LEVER MECHANISM SIMULATOR ---
        (function() {
            window.drawLever = function() {
                const { ctx, width, height } = getCanvasContext('leverCanvas');
                const messageEl = document.getElementById('leverMessage');
                const fulcrumPercent = parseFloat(document.getElementById('lever-fulcrum').value);
                document.getElementById('lever-fulcrum-val').textContent = `${fulcrumPercent.toFixed(0)}%`;

                ctx.clearRect(0, 0, width, height);

                const beamY = height / 2;
                const beamThickness = 10;
                const beamMargin = 40;
                const beamLength = width - 2 * beamMargin;

                const loadMass = 100; // Constant load in kg
                const loadX = beamMargin;
                const effortX = width - beamMargin;

                // Calculate positions and forces
                const fulcrumX = beamMargin + (beamLength * fulcrumPercent / 100);
                const loadArm = fulcrumX - loadX;
                const effortArm = effortX - fulcrumX;
                const effortForce = (loadArm > 0 && effortArm > 0) ? loadMass * (loadArm / effortArm) : Infinity;
                const mechanicalAdvantage = (effortForce > 0) ? loadMass / effortForce : 'Infinite';

                // 1. Draw Beam
                ctx.fillStyle = '#34495e';
                ctx.fillRect(beamMargin, beamY - beamThickness / 2, beamLength, beamThickness);

                // 2. Draw Fulcrum (Triangle)
                const fulcrumHeight = 20;
                ctx.fillStyle = '#7f8c8d';
                ctx.beginPath();
                // The vertex of the triangle should touch the bottom of the beam
                ctx.moveTo(fulcrumX, beamY + beamThickness / 2); // Top vertex
                ctx.lineTo(fulcrumX + 15, beamY + beamThickness / 2 + fulcrumHeight); // Bottom-right corner
                ctx.lineTo(fulcrumX - 15, beamY + beamThickness / 2 + fulcrumHeight); // Bottom-left corner
                ctx.closePath();
                ctx.fill();

                // 3. Draw Load (Box)
                ctx.fillStyle = '#c0392b';
                const loadHeight = 30;
                ctx.fillRect(loadX - 15, beamY - beamThickness / 2 - loadHeight, 30, loadHeight);
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(`${loadMass}kg`, loadX, beamY - beamThickness / 2 - loadHeight / 2 + 3); // Center text in the box

                // 4. Draw Effort (Arrow)
                const arrowLength = 20 + Math.min(effortForce, 150) / 5;
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(effortX, beamY - 50);
                ctx.lineTo(effortX, beamY - 10);
                ctx.stroke(); // Simple line for effort

                messageEl.textContent = `Effort Required: ${effortForce.toFixed(1)} kg | Mechanical Advantage: ${typeof mechanicalAdvantage === 'string' ? mechanicalAdvantage : mechanicalAdvantage.toFixed(1) + 'x'}`;
            }

            window.addEventListener('load', window.drawLever);
            window.addEventListener('resize', window.drawLever);
        })();

        // --- GAME 26: BUOYANCY SIMULATOR ---
        (function() {
            window.drawBuoyancy = function() {
                const { ctx, width, height } = getCanvasContext('buoyancyCanvas');
                const messageEl = document.getElementById('buoyancyMessage');

                const objectDensity = parseFloat(document.getElementById('buoyancy-object-density').value);
                const fluidDensity = parseFloat(document.getElementById('buoyancy-fluid-density').value);

                document.getElementById('buoyancy-object-val').textContent = objectDensity;
                document.getElementById('buoyancy-fluid-val').textContent = fluidDensity;

                ctx.clearRect(0, 0, width, height);

                // 1. Draw Fluid
                const fluidHeight = height * 0.7;
                const fluidY = height - fluidHeight;
                ctx.fillStyle = `rgba(52, 152, 219, 0.6)`;
                ctx.fillRect(0, fluidY, width, fluidHeight);

                // 2. Define Object
                const objectWidth = 60;
                const objectHeight = 60;
                const objectX = width / 2 - objectWidth / 2;
                let objectY;
                let status;

                // 3. Calculate Position and Status
                if (objectDensity > fluidDensity) {
                    // Sinks
                    status = "Sunk";
                    objectY = height - objectHeight - 5; // Rest at the bottom
                } else {
                    // Floats
                    status = "Floating";
                    const submergedPercent = objectDensity / fluidDensity;
                    const submergedHeight = objectHeight * submergedPercent;
                    // The waterline is at fluidY. The object's bottom should be `submergedHeight` below it.
                    objectY = fluidY - (objectHeight - submergedHeight);
                }

                // 4. Draw Object
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(objectX, objectY, objectWidth, objectHeight);
                ctx.strokeStyle = '#c0392b';
                ctx.strokeRect(objectX, objectY, objectWidth, objectHeight);

                // 5. Update Message
                messageEl.textContent = `Status: ${status}`;
            }
            window.addEventListener('load', window.drawBuoyancy);
            window.addEventListener('resize', window.drawBuoyancy);
        })();

        // --- GAME 27: INERTIA EXPLORER ---
        (function() {
            let animationId;
            let block = { x: 0, y: 0, vx: 0, mass: 50, forceDirection: 1 }; // 1 for right, -1 for left

            function drawInertiaSim() {
                const { ctx, width, height } = getCanvasContext('inertiaCanvas');
                ctx.clearRect(0, 0, width, height);

                // Draw Block
                const blockSize = 15 + block.mass / 4; // Size is proportional to mass
                block.y = height / 2;
                ctx.fillStyle = '#34495e';
                ctx.fillRect(block.x - blockSize / 2, block.y - blockSize / 2, blockSize, blockSize);
            }

            function animateInertia() {
                const { width } = getCanvasContext('inertiaCanvas');
                const messageEl = document.getElementById('inertiaMessage');
                const blockSize = 15 + block.mass / 4; // Calculate block size for collision detection

                // Update position
                block.x += block.vx;
                // Apply some drag to slow it down over time
                block.vx *= 0.99;

                // Stop if it hits the wall (using edges, not center) or slows to a stop
                if (block.x + blockSize / 2 > width || block.x - blockSize / 2 < 0 || Math.abs(block.vx) < 0.01) {
                    cancelAnimationFrame(animationId);
                    block.vx = 0;
                    block.x = Math.max(blockSize / 2, Math.min(width - blockSize / 2, block.x)); // Clamp position to its edges
                    block.forceDirection *= -1; // Reverse the force direction for the next push
                    messageEl.textContent = 'Object at rest. Apply force again.';
                } else {
                    animationId = requestAnimationFrame(animateInertia);
                }

                drawInertiaSim();
            }

            window.applyInertiaForce = function() {
                if (animationId) cancelAnimationFrame(animationId);
                const force = 50; // A constant impulse force
                const acceleration = force / block.mass;
                block.vx += acceleration * block.forceDirection; // Apply force in the current direction
                document.getElementById('inertiaMessage').textContent = `Force applied! Acceleration: ${acceleration.toFixed(2)} m/s²`;
                animateInertia();
            }

            window.resetInertiaSim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                const { width } = getCanvasContext('inertiaCanvas');
                block.mass = parseFloat(document.getElementById('inertia-mass').value);
                document.getElementById('inertia-mass-val').textContent = block.mass;
                block.x = width / 2;
                block.vx = 0;
                block.forceDirection = 1; // Reset force direction to right
                document.getElementById('inertiaMessage').textContent = 'Adjust mass and apply force.';
                drawInertiaSim();
            }

            window.addEventListener('load', window.resetInertiaSim);
            window.addEventListener('resize', window.resetInertiaSim);
        })();

        // --- GAME 28: ROTATIONAL INERTIA RACE ---
        (function() {
            let animationId;
            let state = {
                diskAngle: 0,
                ringAngle: 0,
                diskVel: 0,
                ringVel: 0,
                isRunning: false,
                winner: null
            };

            function drawRotationalInertia() {
                const { ctx, width, height } = getCanvasContext('rotationalInertiaCanvas');
                ctx.clearRect(0, 0, width, height);

                const radius = height / 4;
                const diskX = width / 4;
                const ringX = (width / 4) * 3;
                const y = height / 2;

                // Draw Disk
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(diskX, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.save();
                ctx.translate(diskX, y);
                ctx.rotate(state.diskAngle);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(radius, 0);
                ctx.stroke();
                ctx.restore();
                ctx.fillText('Disk', diskX, y + radius + 20);

                // Draw Ring
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.arc(ringX, y, radius - 5, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.save();
                ctx.translate(ringX, y);
                ctx.rotate(state.ringAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(radius, 0);
                ctx.stroke();
                ctx.restore();
                ctx.fillText('Ring', ringX, y + radius + 20);
            }

            function animateRotationalInertia() {
                if (!state.isRunning) return;

                const messageEl = document.getElementById('rotationalInertiaMessage');
                const torque = 0.0005; // A constant torque applied to both

                // I_disk = 1/2 MR^2, I_ring = MR^2. So alpha_disk = 2 * alpha_ring
                const alpha_disk = torque; // Let's simplify I_disk to 1 unit
                const alpha_ring = torque / 2; // I_ring is double I_disk

                state.diskVel += alpha_disk;
                state.ringVel += alpha_ring;

                state.diskAngle += state.diskVel;
                state.ringAngle += state.ringVel;

                drawRotationalInertia();

                // Check for a winner
                if (!state.winner) {
                    if (state.diskAngle >= 2 * Math.PI) {
                        state.winner = 'Disk';
                        messageEl.textContent = 'The Disk wins! It has lower rotational inertia.';
                        state.isRunning = false;
                    } else if (state.ringAngle >= 2 * Math.PI) {
                        // This case is unlikely but included for completeness
                        state.winner = 'Ring';
                        messageEl.textContent = 'The Ring wins!';
                        state.isRunning = false;
                    }
                }

                if (state.isRunning) {
                    animationId = requestAnimationFrame(animateRotationalInertia);
                }
            }

            window.resetRotationalInertiaSim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                Object.assign(state, { diskAngle: 0, ringAngle: 0, diskVel: 0, ringVel: 0, isRunning: false, winner: null });
                document.getElementById('rotationalInertiaMessage').textContent = 'Press "Start Race" to apply torque.';
                drawRotationalInertia();
            }

            window.startRotationalInertiaRace = function() {
                if (state.isRunning || state.winner) return; // Don't start if already running or finished
                state.isRunning = true;
                animateRotationalInertia();
            }

            window.addEventListener('load', window.resetRotationalInertiaSim);
            window.addEventListener('resize', window.resetRotationalInertiaSim);
        })();

        // --- GAME 29: NEWTON'S THIRD LAW SIMULATOR ---
        (function() {
            let animationId;
            let objA = { x: 0, vx: 0, mass: 20 };
            let objB = { x: 0, vx: 0, mass: 80 };

            function drawNewtonThirdLaw() {
                const { ctx, width, height } = getCanvasContext('newtonThirdLawCanvas');
                ctx.clearRect(0, 0, width, height);

                const yPos = height / 2;
                const sizeA = 15 + objA.mass / 4;
                const sizeB = 15 + objB.mass / 4;

                // Draw Object A
                ctx.fillStyle = '#3498db';
                ctx.fillRect(objA.x - sizeA / 2, yPos - sizeA / 2, sizeA, sizeA);

                // Draw Object B
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(objB.x - sizeB / 2, yPos - sizeB / 2, sizeB, sizeB);
            }

            function animateInteraction() {
                const { width } = getCanvasContext('newtonThirdLawCanvas');
                const sizeA = 15 + objA.mass / 4;
                const sizeB = 15 + objB.mass / 4;
                
                objA.x += objA.vx;
                objB.x += objB.vx;

                // Apply drag
                objA.vx *= 0.98;
                objB.vx *= 0.98;

                // Stop at walls, considering object size
                if (objA.x - sizeA / 2 < 0) { objA.x = sizeA / 2; objA.vx = 0; }
                if (objB.x + sizeB / 2 > width) { objB.x = width - sizeB / 2; objB.vx = 0; }

                drawNewtonThirdLaw();

                if (Math.abs(objA.vx) < 0.01 && Math.abs(objB.vx) < 0.01) {
                    cancelAnimationFrame(animationId);
                } else {
                    animationId = requestAnimationFrame(animateInteraction);
                }
            }

            window.triggerInteraction = function() {
                if (animationId) cancelAnimationFrame(animationId);

                // Check if objects are touching before allowing an interaction
                const sizeA = 15 + objA.mass / 4;
                const sizeB = 15 + objB.mass / 4;
                if (objB.x - sizeB / 2 > objA.x + sizeA / 2) {
                    document.getElementById('newtonThirdLawMessage').textContent = 'Cannot interact. Objects are not touching.';
                    return; // Exit if there's a gap
                }

                const force = 50; // The "action" force
                const accelA = force / objA.mass;
                const accelB = force / objB.mass;
                objA.vx = -accelA; // Equal and opposite reaction
                objB.vx = accelB;
                document.getElementById('newtonThirdLawMessage').textContent = `Interaction! a_A: ${accelA.toFixed(2)}, a_B: ${accelB.toFixed(2)}`;
                animateInteraction();
            }

            window.resetNewtonThirdLawSim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                const { width } = getCanvasContext('newtonThirdLawCanvas');
                const massA = parseFloat(document.getElementById('newton-mass-a').value);
                const massB = parseFloat(document.getElementById('newton-mass-b').value);
                const sizeA = 15 + massA / 4;
                const sizeB = 15 + massB / 4;

                objA = { mass: massA, vx: 0, x: width / 2 - sizeA / 2 };
                objB = { mass: massB, vx: 0, x: width / 2 + sizeB / 2 };
                document.getElementById('newton-mass-a-val').textContent = objA.mass;
                document.getElementById('newton-mass-b-val').textContent = objB.mass;
                document.getElementById('newtonThirdLawMessage').textContent = 'Adjust masses and trigger the interaction.';
                drawNewtonThirdLaw();
            }

            window.addEventListener('load', window.resetNewtonThirdLawSim);
            window.addEventListener('resize', window.resetNewtonThirdLawSim);
        })();

        // --- GAME 30: BERNOULLI'S PRINCIPLE SIMULATOR ---
        (function() {
            window.drawBernoulli = function() {
                const { ctx, width, height } = getCanvasContext('bernoulliCanvas');
                const messageEl = document.getElementById('bernoulliMessage');
                const constrictionPercent = parseFloat(document.getElementById('bernoulli-constriction').value);
                document.getElementById('bernoulli-constriction-val').textContent = `${constrictionPercent}%`;

                ctx.clearRect(0, 0, width, height);

                const pipeY = height / 2;
                const wideHeight = 80;
                const narrowHeight = wideHeight * (constrictionPercent / 100);

                const narrowX = width * 0.4;
                const narrowWidth = width * 0.2;

                // --- Calculations ---
                const area1 = wideHeight;
                const area2 = narrowHeight;
                const v1 = 1.0; // Assume initial velocity is 1 m/s
                const v2 = v1 * (area1 / area2); // Continuity Equation

                const P1 = 100000; // 100 kPa initial pressure
                const rho = 1000; // Density of water
                const P2 = P1 + 0.5 * rho * (v1*v1 - v2*v2); // Bernoulli's Equation

                // --- Color Definitions ---
                const color1 = 'rgba(52, 152, 219, 0.2)'; // Blue for wide section
                const color2 = 'rgba(230, 126, 34, 0.2)'; // Orange for narrow section

                // --- Draw Pipe ---
                ctx.strokeStyle = '#34495e';
                ctx.lineWidth = 3;
                ctx.beginPath();
                // Top wall
                ctx.moveTo(0, pipeY - wideHeight / 2);
                ctx.lineTo(narrowX, pipeY - wideHeight / 2);
                ctx.lineTo(narrowX, pipeY - narrowHeight / 2);
                ctx.lineTo(narrowX + narrowWidth, pipeY - narrowHeight / 2);
                ctx.lineTo(narrowX + narrowWidth, pipeY - wideHeight / 2);
                ctx.lineTo(width, pipeY - wideHeight / 2);
                // Bottom wall
                ctx.moveTo(0, pipeY + wideHeight / 2);
                ctx.lineTo(narrowX, pipeY + wideHeight / 2);
                ctx.lineTo(narrowX, pipeY + narrowHeight / 2);
                ctx.lineTo(narrowX + narrowWidth, pipeY + narrowHeight / 2);
                ctx.lineTo(narrowX + narrowWidth, pipeY + wideHeight / 2);
                ctx.lineTo(width, pipeY + wideHeight / 2);
                ctx.stroke();

                // --- Fill Colored Areas ---
                // Wide Area 1 (Left)
                ctx.fillStyle = color1;
                ctx.fillRect(0, pipeY - wideHeight / 2, narrowX, wideHeight);
                // Narrow Area 2
                ctx.fillStyle = color2;
                ctx.fillRect(narrowX, pipeY - narrowHeight / 2, narrowWidth, narrowHeight);
                // Wide Area 1 (Right)
                ctx.fillStyle = color1;
                ctx.fillRect(narrowX + narrowWidth, pipeY - wideHeight / 2, width - (narrowX + narrowWidth), wideHeight);

                // --- Update Message ---
                const text1 = `<span style="color: #3498db; font-weight: bold;">V₁: ${v1.toFixed(1)} m/s, P₁: ${(P1/1000).toFixed(1)} kPa</span>`;
                const text2 = `<span style="color: #e67e22; font-weight: bold;">V₂: ${v2.toFixed(1)} m/s, P₂: ${(P2/1000).toFixed(1)} kPa</span>`;
                messageEl.innerHTML = `${text1} | ${text2}`;
            }

            window.addEventListener('load', window.drawBernoulli);
            window.addEventListener('resize', window.drawBernoulli);
        })();

        // --- GAME 31: LIGHT REFRACTION & ABSORPTION ---
        (function() {
            window.drawRefraction = function() {
                const { ctx, width, height } = getCanvasContext('refractionCanvas');
                const messageEl = document.getElementById('refractionMessage');

                const angle1_deg = parseFloat(document.getElementById('refraction-angle').value);
                const n2 = parseFloat(document.getElementById('refraction-medium').value);
                document.getElementById('refraction-angle-val').textContent = `${angle1_deg}°`;

                const n1 = 1.00; // Refractive index of top medium (Air)
                const angle1_rad = angle1_deg * (Math.PI / 180);

                ctx.clearRect(0, 0, width, height);

                // --- Draw Media ---
                const interfaceY = height / 2;
                // Top Medium (Air)
                ctx.fillStyle = 'rgba(236, 240, 241, 0.3)';
                ctx.fillRect(0, 0, width, interfaceY);
                // Bottom Medium
                ctx.fillStyle = `rgba(52, 152, 219, ${0.1 * n2})`; // Color density based on n
                ctx.fillRect(0, interfaceY, width, height - interfaceY);

                // --- Draw Normal Line ---
                const impactX = width / 2;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(impactX, 0);
                ctx.lineTo(impactX, height);
                ctx.stroke();
                ctx.setLineDash([]);

                // --- Draw Incident Ray ---
                const rayLength = height;
                const startX = impactX - rayLength * Math.sin(angle1_rad);
                const startY = interfaceY - rayLength * Math.cos(angle1_rad);
                ctx.strokeStyle = '#f1c40f'; // Yellow for light
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(impactX, interfaceY);
                ctx.stroke();

                // --- Calculate Refraction/Reflection ---
                const sin_angle2 = (n1 / n2) * Math.sin(angle1_rad);

                if (sin_angle2 > 1) { // Total Internal Reflection
                    const endX = impactX + rayLength * Math.sin(angle1_rad);
                    const endY = startY;
                    ctx.globalAlpha = 0.8; // Reflected ray is slightly dimmer
                    ctx.beginPath();
                    ctx.moveTo(impactX, interfaceY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    messageEl.textContent = `Total Internal Reflection! θ₁ = θ_reflection = ${angle1_deg.toFixed(1)}°`;
                } else { // Refraction
                    const angle2_rad = Math.asin(sin_angle2);
                    const endX = impactX + rayLength * Math.sin(angle2_rad);
                    const endY = interfaceY + rayLength * Math.cos(angle2_rad);
                    ctx.globalAlpha = 1 - (0.1 * n2); // Absorption: dimmer in denser material
                    ctx.beginPath();
                    ctx.moveTo(impactX, interfaceY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    messageEl.textContent = `θ₁: ${angle1_deg.toFixed(1)}°, θ₂: ${(angle2_rad * 180 / Math.PI).toFixed(1)}°`;
                }
                ctx.globalAlpha = 1.0; // Reset alpha
            }

            window.addEventListener('load', window.drawRefraction);
            window.addEventListener('resize', window.drawRefraction);
        })();

        // --- GAME 32: LITHIUM-ION BATTERY SIMULATOR ---
        (function() {
            let animationId;
            let particles = [];
            const NUM_PARTICLES = 20;
            // Add a separate array for electrons
            let electrons = [];
            const NUM_ELECTRONS = 30;

            let state = 'charged'; // charged, charging, discharging

            function drawBattery(ctx, width, height) {
                ctx.clearRect(0, 0, width, height);

                const anodeX = 0, anodeWidth = width * 0.4;
                const cathodeX = width * 0.6, cathodeWidth = width * 0.4;
                const separatorX = width * 0.4, separatorWidth = width * 0.2;

                // Draw Anode (Graphite)
                ctx.fillStyle = '#555';
                ctx.fillRect(anodeX, 0, anodeWidth, height);
                ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.fillText('Anode (-)', anodeWidth / 2, 20);

                // Draw Cathode (LiCoO2)
                ctx.fillStyle = '#3498db';
                ctx.fillRect(cathodeX, 0, cathodeWidth, height);
                ctx.fillStyle = 'white'; ctx.fillText('Cathode (+)', cathodeX + cathodeWidth / 2, 20);

                // Draw Separator
                ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.fillRect(separatorX, 0, separatorWidth, height);

                // Draw External Circuit
                const circuitY = height / 2;
                ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(anodeWidth, circuitY); ctx.lineTo(cathodeX, circuitY);
                ctx.stroke();

                // --- Draw Bulb or Power Source ---
                const bulbX = width / 2;
                const bulbY = circuitY - 20;

                // Draw bulb base
                ctx.fillStyle = '#888';
                ctx.fillRect(bulbX - 7, bulbY + 8, 14, 5);

                // Draw glass outline
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(bulbX, bulbY, 12, Math.PI * 0.9, Math.PI * 0.1, true);
                ctx.stroke();

                if (state === 'discharging') {
                    // Calculate discharge progress by how many ions have reached the cathode
                    const arrivedCount = particles.filter(p => p.x > cathodeX).length;
                    const dischargeProgress = arrivedCount / NUM_PARTICLES;
                    const brightness = Math.max(0, 1 - dischargeProgress);

                    // Add a prominent glow effect
                    if (brightness > 0.1) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = `rgba(255, 255, 0, 0.7)`;
                        ctx.fillStyle = `rgba(255, 255, 0, ${brightness})`;
                        ctx.beginPath(); ctx.arc(bulbX, bulbY, 8, 0, 2 * Math.PI); ctx.fill();
                        ctx.shadowBlur = 0; // Reset shadow for other elements
                    }
                    // Draw glowing filament
                    ctx.strokeStyle = `rgba(255, 235, 59, ${brightness})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(bulbX - 4, bulbY); ctx.lineTo(bulbX + 4, bulbY); ctx.stroke();
                } else if (state === 'charging') {
                    // Draw Power Source for charging
                    ctx.fillStyle = '#27ae60';
                    ctx.fillRect(bulbX - 15, bulbY - 5, 30, 10);
                    ctx.fillStyle = 'white';
                    ctx.fillText('+', bulbX + 10, bulbY + 3);
                    ctx.fillText('-', bulbX - 10, bulbY + 3);
                }

                // Draw Particles
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;

                    ctx.fillStyle = '#3498db'; // Ions are blue
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.type === 'ion' ? 4 : 2, 0, 2 * Math.PI); ctx.fill();
                });

                // Draw Electrons
                electrons.forEach(e => {
                    e.x += e.vx;
                    e.y += e.vy;
                    ctx.fillStyle = '#f1c40f'; // Electrons are yellow
                    ctx.beginPath(); ctx.arc(e.x, e.y, 2, 0, 2 * Math.PI); ctx.fill();
                });
            }

            function animateBattery() {
                const { ctx, width, height } = getCanvasContext('batteryCanvas');
                const anodeWidth = width * 0.4;
                const cathodeX = width * 0.6;
                const circuitY = height / 2;

                // --- Update Ion Positions ---
                particles.forEach(p => {
                    const dx = p.targetX - p.x;
                    const dy = p.targetY - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        p.vx = (dx / dist) * 1.5; // Move towards target
                        p.vy = (dy / dist) * 1.5;
                    } else {
                        p.vx = (Math.random() - 0.5) * 0.5; // Random motion at target
                        p.vy = (Math.random() - 0.5) * 0.5;

                        // Check if all ions have arrived
                        if (state === 'discharging' || state === 'charging') {
                            const allArrived = particles.every(p => Math.sqrt(Math.pow(p.targetX - p.x, 2) + Math.pow(p.targetY - p.y, 2)) <= 1);
                            if (allArrived) {
                                state = (state === 'discharging') ? 'discharged' : 'charged';
                            }
                        }
                    }
                });

                // --- Update Electron Positions ---
                electrons.forEach(e => {
                    if (e.pathIndex === 0 && e.x > width / 2) e.pathIndex = 1;
                    if (e.pathIndex === 1 && e.y < circuitY - 20) e.pathIndex = 2;
                    if (e.pathIndex === 2 && ( (e.vx > 0 && e.x > width/2) || (e.vx < 0 && e.x < width/2) ) ) e.pathIndex = 3;
                    if (e.pathIndex === 3 && e.y > circuitY) e.pathIndex = 4;

                    if (e.pathIndex === 4) { // Reached destination
                        e.vx = e.vy = 0;
                    } else {
                        const target = e.path[e.pathIndex];
                        const dx = target.x - e.x;
                        const dy = target.y - e.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        e.vx = (dx / dist) * 2;
                        e.vy = (dy / dist) * 2;
                    }
                });

                drawBattery(ctx, width, height);
                animationId = requestAnimationFrame(animateBattery);
            }

            function setupParticles(ionArea) {
                particles = [];
                electrons = [];
                const { width, height } = getCanvasContext('batteryCanvas');
                const anodeWidth = width * 0.4;
                const cathodeX = width * 0.6;
                const circuitY = height / 2;

                for (let i = 0; i < NUM_PARTICLES; i++) {
                    const isAnode = ionArea === 'anode';
                    const x = isAnode ? Math.random() * anodeWidth : cathodeX + Math.random() * (width - cathodeX);
                    const y = Math.random() * height;
                    particles.push({
                        x: x, y: y, targetX: x, targetY: y,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        type: 'ion'
                    });
                }

                for (let i = 0; i < NUM_ELECTRONS; i++) {
                    const startX = ionArea === 'anode' ? anodeWidth : cathodeX;
                    electrons.push({
                        x: startX, y: circuitY, vx: 0, vy: 0,
                        path: [], pathIndex: 4 // Start at the end
                    });
                }
            }

            window.resetBatterySim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                animationId = null;
                state = 'charged';
                setupParticles('anode');
                document.getElementById('batteryMessage').textContent = 'Battery is charged. Press Discharge to use.';
                const { ctx, width, height } = getCanvasContext('batteryCanvas');
                drawBattery(ctx, width, height);
            }
            
            function startAnimation(ionTargetArea, electronStart, electronEnd, message) {
                if (animationId) cancelAnimationFrame(animationId);
                document.getElementById('batteryMessage').textContent = message;
                const { width, height } = getCanvasContext('batteryCanvas');
                const anodeWidth = width * 0.4;
                const cathodeX = width * 0.6;
                const circuitY = height / 2;

                particles.forEach(p => {
                    p.targetX = ionTargetArea === 'anode' ? Math.random() * anodeWidth : cathodeX + Math.random() * (width - cathodeX);
                    p.targetY = Math.random() * height;
                });

                electrons.forEach(e => {
                    e.x = electronStart; e.y = circuitY; e.pathIndex = 0;
                    e.path = [ {x: electronStart, y: circuitY - 20}, {x: electronEnd, y: circuitY - 20}, {x: electronEnd, y: circuitY}, {x: electronEnd, y: circuitY} ];
                });

                animateBattery();
            }

            window.startBatteryDischarge = function() { state = 'discharging'; startAnimation('cathode', getCanvasContext('batteryCanvas').width * 0.4, getCanvasContext('batteryCanvas').width * 0.6, 'Discharging... Powering device.'); }
            window.startBatteryCharge = function() { state = 'charging'; startAnimation('anode', getCanvasContext('batteryCanvas').width * 0.6, getCanvasContext('batteryCanvas').width * 0.4, 'Charging... Storing energy.'); }

            window.addEventListener('load', window.resetBatterySim);
            window.addEventListener('resize', window.resetBatterySim);
        })();

        // --- GAME 25: INCLINED PLANE SIMULATOR ---
        (function() {
            const g = 9.8;
            let animationId;
            let block = { pos: 0.1, v: 0 }; // pos is % along the ramp, v is velocity

            function drawInclinedPlane(forces) {
                const { ctx, width, height } = getCanvasContext('inclinedPlaneCanvas');
                const angleDeg = parseFloat(document.getElementById('plane-angle').value);
                const angleRad = angleDeg * (Math.PI / 180);

                ctx.clearRect(0, 0, width, height);

                // --- Draw Plane ---
                const planeBaseY = height - 10; // Move base to 10px from the bottom for a closer fit
                const rampLength = width * 0.55; // This is the hypotenuse
                const planeLength = rampLength * Math.cos(angleRad); // The base of the triangle
                const planeHeight = rampLength * Math.sin(angleRad); // The height of the triangle
                const planeStartX = (width - planeLength) / 2; // Center the ramp horizontally
                const planeEndX = planeStartX + planeLength;

                ctx.fillStyle = '#bdc3c7';
                ctx.beginPath();
                ctx.moveTo(planeStartX, planeBaseY);
                ctx.lineTo(planeEndX, planeBaseY);
                ctx.lineTo(planeEndX, planeBaseY - planeHeight);
                ctx.closePath();
                ctx.fill();

                // --- Draw Block and Forces ---
                const blockX = planeStartX + (rampLength * block.pos * Math.cos(angleRad));
                const blockY = planeBaseY - (rampLength * block.pos * Math.sin(angleRad));
                const blockSize = 20 + forces.mass;

                ctx.save();
                ctx.translate(blockX, blockY);
                ctx.rotate(-angleRad);

                // Draw Block
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(-blockSize / 2, -blockSize, blockSize, blockSize);

                // Draw Force Vectors (relative to block center)
                const blockCenterX = 0;
                const blockCenterY = -blockSize / 2;

                // Applied Force
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(blockCenterX, blockCenterY);
                ctx.lineTo(blockCenterX - forces.applied, blockCenterY);
                ctx.stroke();

                // Parallel Force
                ctx.strokeStyle = '#e67e22';
                ctx.beginPath();
                ctx.moveTo(blockCenterX, blockCenterY);
                ctx.lineTo(blockCenterX + forces.parallel, blockCenterY);
                ctx.stroke();

                ctx.restore();
            }

            function animateInclinedPlane() {
                const { width } = getCanvasContext('inclinedPlaneCanvas');
                const rampLength = width * 0.8;

                const forces = getForces();
                let frictionForce = forces.normal * forces.mu_k;
                
                // Friction opposes motion
                if (block.v < 0) frictionForce *= -1;

                const netForce = forces.applied - forces.parallel - frictionForce;
                const acceleration = netForce / forces.mass;

                block.v += acceleration * 0.01; // dt
                block.pos += (block.v / rampLength) * 0.5; // Scale velocity to ramp length

                // Stop if it goes off the ends
                if (block.pos >= 1 || block.pos <= 0) {
                    cancelAnimationFrame(animationId);
                    block.pos = Math.max(0, Math.min(1, block.pos));
                    block.v = 0;
                    document.getElementById('inclinedPlaneMessage').textContent = `Finished! Net Force: ${netForce.toFixed(1)} N`;
                } else {
                    document.getElementById('inclinedPlaneMessage').textContent = `Moving... Net Force: ${netForce.toFixed(1)} N`;
                    animationId = requestAnimationFrame(animateInclinedPlane);
                }
                
                drawInclinedPlane(forces);
            }

            function getForces() {
                const angleDeg = parseFloat(document.getElementById('plane-angle').value);
                const mass = parseFloat(document.getElementById('plane-mass').value);
                const mu_k = parseFloat(document.getElementById('plane-friction').value);
                const applied = parseFloat(document.getElementById('plane-force').value);
                const angleRad = angleDeg * (Math.PI / 180);

                const gravityForce = mass * g;
                const normalForce = gravityForce * Math.cos(angleRad);
                const parallelForce = gravityForce * Math.sin(angleRad);

                return { mass, mu_k, applied, normal: normalForce, parallel: parallelForce };
            }

            window.resetInclinedPlaneSim = function() {
                if (animationId) cancelAnimationFrame(animationId);
                block = { pos: 0.1, v: 0 };
                
                document.getElementById('plane-angle-val').textContent = `${document.getElementById('plane-angle').value}°`;
                document.getElementById('plane-mass-val').textContent = document.getElementById('plane-mass').value;
                document.getElementById('plane-friction-val').textContent = parseFloat(document.getElementById('plane-friction').value).toFixed(2);
                document.getElementById('plane-force-val').textContent = document.getElementById('plane-force').value;

                const forces = getForces();
                drawInclinedPlane(forces);

                // Update Message
                document.getElementById('inclinedPlaneMessage').textContent = `Parallel: ${forces.parallel.toFixed(1)} N | Normal: ${forces.normal.toFixed(1)} N. Ready.`;
            }

            window.startInclinedPlaneSim = function() {
                resetInclinedPlaneSim();
                animateInclinedPlane();
            }

            window.addEventListener('load', window.resetInclinedPlaneSim);
            window.addEventListener('resize', window.resetInclinedPlaneSim);
        })();

        // --- Final Setup ---
        window.addEventListener('load', () => {
            // Re-run all load functions to ensure all initial states are set after all scripts are parsed
            window.updateRegressionPlot();
            window.drawQuadratic();
            window.resetHeatSim();
            window.generateComplement();
            window.resetArray();
            window.resetCogSim();
            window.updateColorMixer();
            window.applyCipher();
            window.convertUnit();
            window.updateShm(true);
            window.convertToDecimal();
            window.checkPrime();
            window.calculateOhm();
            window.calculatePh();
            window.addVectors();
            // window.initOceanSim(); // Don't auto-start this one
            window.classifyStar();
            window.calculateVolume();
            window.calculateFibonacci();
            window.resetFrictionSim();
            window.resetEnergySim();
            window.resetDopplerSim();
            window.resetInclinedPlaneSim();
            window.drawCantilever();
            window.drawLever();
            window.drawBuoyancy();
            window.resetInertiaSim();
            window.resetRotationalInertiaSim();
            window.resetNewtonThirdLawSim();
            window.drawBernoulli();
            window.drawRefraction();
            window.resetBatterySim();
        });

    </script>
</body>
</html>